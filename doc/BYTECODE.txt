
SEE's intermediate bytecode representation
------------------------------------------

This document describes and defines SEE's intermediate code generation
virtual machine model and instructions.

SEE is designed to support different code generators. The model defined
in this document is an interface between the parser and the code generation-
execution back-end which implements the virtual machine.

The virtual machine executes a sequence of virtual instructions.
The instructions operate on:

    * the environment available through a SEE_context structure
    * a bounded stack of SEE_values ("the value stack")
    * a bounded stack of 'blocks' (eg TRY,WITH. "the block stack")
    * a bounded array of local variable values (see VREF instruction)
    * the 'C' register (the last value resulting from a statement)
    * the 'L' register (a SEE_location)
    * the 'E' register (current enumeration, see B.ENUM)
    * The 'PC' register (the current instruction stream index)

A sequence of instructions implements a SourceElements production
minus any FunctionDeclarations. That is, the code generator is used to
build bytecode that implements exactly one function. Thus, there is only
one entry point.

This document does not define a physical byte code format, instead
it defines the instructions identified by the enumerated types of code.h.
Some instructions take operands. It is up to the code generator how to
encode these operands. The operands to instructions include:

    * address operands (branch and block instructions)
    * integer operands (actual parameter count for call instructions)
    * literal SEE_value (for the LITERAL instruction)

The value stack
---------------

The value stack is used for computing expressions. Most of the instructions
described in this file work on the value stack.

See the section on 'Notation' below for more information on how the
top content of the value stack is represented in this document.

The block stack
---------------

Some of the instructions in this file work on the block stack. The block 
stack is used for keeping track of:

    * enumerators ('for ... in')
    * try-catch and try-finally handling
    * scope extension ('with')

Blocks are created using S.ENUM, S.TRYC, S.TRYF, S.WITH instructions, and
are numbered from one. Some block types cannot be directly created by an
instruction. All blocks end with the END instruction, which can end
multiple blocks. Ending block zero (END,0) terminates the function and
returns the C register to the caller. This is how 'return' is implemented.

The process of ending a block will have side effects depending on the block
being ended. For example, ending the FINALLY block transfers control to a
finally handler, and pushes a FINALLY2 block onto the block stack (whose 
purpose is to restore C and PC correctly when it is ended).

Generally, expressions will make use of the value stack, while statements 
will make use of the block stack and the C register.

Initial conditions
------------------

    PC = initial instruction
    C  = undefined
    L  = not defined
    E  = not defined
    block stack = empty
    value stack = empty

INSTRUCTION SUMMARY
===================

Notation
--------

Instructions marked with a '*' below may throw exceptions. Instructions 
without a '*' do not throw exceptions.

Instructions that operate on the value stack describe the before and after
states of the stack in the form "before | after". For example, the
subtraction operator SUB is indicated like this:

	SUB    num1 num2 | num3

Indicating that num2 is first popped off the stack, followed by num1,
then num3 is pushed. On both sides, the top of the stack is always 
written rightmost in the list.  An empty list is represented by '-'.

The elements on the value stack are of constrained types. For example
the 'num2' element above is a number value. The abbreviations of the
value types, and (some union types) are:

    * bool	- SEE_BOOLEAN
    * num	- SEE_NUMBER
    * str	- SEE_STRING
    * obj	- SEE_OBJECT
    * ref	- SEE_REFERENCE (possibly)
    * cmpl	- SEE_COMPLETION
    * null	- SEE_NULL
    * undef	- SEE_UNDEFINED

    * any	- any SEE_value (i.e. unknown type)
                  i.e. { bool + num + str + obj + ref + cmpl + null + undef }

    * val	- values; same as 'any', but excluding 'cmpl' or 'ref'
                  i.e. { bool + num + str + obj + null + undef }

    * prim	- primitives; The same as 'val', but excluding 'obj'
                  i.e. { bool + num + str + null + undef }


Call instructions
-----------------

*   NEW,n 	objC any1..anyn | objR

	1. If typeof(objC) is not object, throw a TypeError exception.
	2. If objC does not implement [[Construct]] throw a TypeError exception.
	3. Call the [[Construct]] method on objC, providing any0..anyn as
	   the argument values (may be empty, i.e. n = 0) setting .
	4. Let objR be the result of the previous [[Construct]] call.

*   CALL,n 	anyC any1..anyn | valR 

	1. Compute objC = GetValue(anyC).
	2. If typeof(objC) is not object, throw a TypeError exception.
	3. If objC does not implement [[Call]] throw a TypeError exception.
	4. If anyC is a reference, let t = GetBase(anyC),
	   otherwise let t = NULL.
	5. If t is an activation object then set t = NULL.
	6. Call the [[Call]] method on objC, providing any0..anyn as the
	   argument values (may be empty).
	7. Let valR be the result of the previous [[Call]] call.

    Note: The L, C, E registers are unchanged by the CALL/NEW instructions.


Special instructions
--------------------

    FUNC,func	    - | obj
	Binds a function instance object to the current scope
	and pushes it onto the stack.

    LITERAL,val    - | val
	Pushes a copy of a literal value onto the stack.

    LOC,filename,lineno      - | -
	Sets the current location ('L' register).


    Notes: Implementations are encouraged to generate fixed tables (of 
    functions, literals and location tags) during parse, and then to use 
    integer arguments to the special instructions above.


Generic instructions
--------------------

    NOP		   - | -
	No operation. (Used for padding)

    DUP		any1 | any1 any1
	Duplicates the value on top of the stack

    POP		any1 | -
	Removes the topmost element on the stack

    EXCH	    any1 any2 | any2 any1
	Exchanges the top two elements on the stack

    ROLL3	    any1 any2 any3 | any3 any1 any2
	Rotates the top three elements. The top element is
	pushed down past the next two elements, and those two elements
	rise up by one position.


Miscellaneous instructions
--------------------------

*   THROW	    val | ?
	Throws an exception consisting of the given value

    SETC	val | -
	Sets the C register to the given value. 

    GETC	- | val
	Pushes the value of the C register 


Context instructions
--------------------

    THIS	- | obj
	Pushes the 'this' object from the current context

    OBJECT	- | obj
	Pushes the object interp->Object onto the stack

    ARRAY	- | obj
	Pushes the object interp->Array onto the stack

    REGEXP	- | obj
	Pushes the object interp->Regexp onto the stack


Primitive instructions
----------------------

    REF		obj str | ref
	Creates a reference value by combining obj and str.

*   GETVALUE	ref | val
	Computes GetValue(ref) (8.7.1), i.e. val = ref.[[Get]]

    LOOKUP	str | ref
	Creates a reference by looking up an identifier in the current 
	scope (10.1.4)

*   PUTVALUE	ref val | -
	Computes PutValue(ref, val) (8.7.2), i.e ref.[[Put]](val)

    VREF,n	- | ref
	Returns a reference to a variable. Variables are always referenced
	from the context variable object. Variables are always initialised
	to undefined in the variables object before the function body begins,
	unless they already exist.  The VREF instruction is equivalent to a 
	LOOKUP with the variable name when the variable object is closest
	in scope.

*   DELETE	any1 | bool
	1. If any is not a reference, then pushes TRUE
	2. Otherwise call [[Delete]] on the reference (11.4.1)
	3. Push the result of the [[Delete]] call

    TYPEOF	any | str
	1. If any is a reference with null base, then 
	   let v = undefined
	2. If any is a reference with a non-null base, then
	   let v = GetValue(any)
	3. If any is not a reference, then let v = any
	3. Push a string representing the type of v (11.4.3)

Conversion instructions
-----------------------

*   TOOBJECT	val | obj
	Calls ToObject(val) (9.9). May throw an exception

*   TONUMBER	val | num
	Calls ToObject(val) (9.3). May throw an exception

    TOBOOLEAN	val | bool
	Calls ToBoolean(val) (9.2)

*   TOSTRING	val | str
	Calls ToString(val) (9.8). May throw an exception

*   TOPRIMITIVE	val | prim
	Calls ToPrimitive(val) (9.1) May thrown an exception

    Notes: These instructions have no effect when the value on the top
    of the stack is already the right type. Peephole optimization can 
    occur when the type constraints of instructions obviate the need 
    for conversions. For example, the DELETE instruction always pushes 
    a boolean; so an immediately subsequent TOBOOLEAN instruction can be
    removed.


Arithmetic instructions (11.6.3)
-----------------------

    NEG		num1 -> num2
	If num1 is NaN, then let num2 = NaN
	otherwise let num2 = -num1	(i.e. num1 with opposite sign)

    INV		val1 -> num2
	Let num2 = ~ToInt32(val1) (i.e. bitwise one's complement)

    NOT		bool1 -> bool2
	Let bool2 = !bool1 (i.e. logical inverse)

    MUL		num1 num2 | num3
    DIV		num1 num2 | num3
    MOD		num1 num2 | num3
	Let num3 = num1 [*/%] num2 (see 11.5)

*   ADD		prim1 prim2 | prim3
	If either of prim1 or prim2 is a string then
	    let prim3 = concat(ToString(prim1), ToString(prim2))
	otherwise
	    let prim3 = ToNumber(prim1) + ToNumber(prim2)

    SUB		num1 num2 | num3
	Let num3 = num1 - num2

    LSHIFT	val1 val2 | num3
	Let num3 = ToInt32(val1) << (ToUint32(val2) & 0x1f)

    RSHIFT	val1 val2 | num3
	Let num3 = ToInt32(val1) >> (ToUint32(val2) & 0x1f) 
	The most significant bit is propagated, and the result is signed.

    URSHIFT	val1 val2 | num3
	Let num3 = ToUint32(val1) >> (ToUint32(val2) & 0x1f)
	The most signifiant bit of result is set to zero, and the result is
	an positive 31 bit integer. (11.7.3)


Relational instructions (11.8)
-----------------------

    LT		val1 val2 | bool
	Compute val1 < val2 (see 11.8.1)

    GT		val1 val2 | bool
	Compute val1 > val2 (see 11.8.2)

    LE		val1 val2 | bool
	Compute val1 <= val2 (see 11.8.3)

    GE		val1 val2 | bool
	Compute val1 >= val2 (see 11.8.4)

*   INSTANCEOF	val1 val2 | bool
	1. If val2 is not an object, throws a TypeError exception
	2. compute val2.[[HasInstance]](val1)

*   IN		str1 val2 | bool
	1. if val2 is not an object, throws a TypeError exception
	2. compute val2.[[HasProperty]](str1)

    EQ		val1 val2 | bool
	Compute val1 == val2 (see 11.9.3)

    SEQ		val1 val2 | bool
	Compute val1 === val2 (see 11.9.6)


Binary bitwise instructions (11.10)
---------------------------

    BAND	val1 val2 | num3
    BXOR	val1 val2 | num3
    BOR		val1 val2 | num3
	Compute num3 = ToInt32(val1) @ ToInt32(val2)


Branch instructions
-------------------

    B.ALWAYS,x 	    - | -
	Sets PC = x

    B.TRUE,x	 bool | -
	If bool is true, then set PC = x

    B.ENUM,x	    - | - str		(when branch IS taken)
		    - | -		(when branch IS NOT taken)
	If the enumeration register E is exhausted, branches to <x>.
	Otherwise, pushes the next identifier string from E onto the value
	stack and does not branch.
	The B.ENUM instruction only returns strings str where 
	obj.[[HasProperty]](str) is true. (This is checked each time).


Block instructions
------------------

    S.ENUM	    obj | -
	Pushes an enumeration block. See B.ENUM instruction and
	the section below on 'The ENUM block'.
	
	Conceptually, this instruction saves register E, and
	then sets E to the enumeration of obj.

    S.WITH	    obj | -
	Inserts obj into the front of the context's scope chain,
	and pushes a 'WITH' block. See 'The WITH block', below.

    S.TRYC,x	    str | -
	Creates and pushes a CATCH block. See 'The CATCH block' below.
	The address x indicates the entry point of the catch handler.

    S.TRYF,x	    - | -
	Creates and pushes a FINALLY block. See 'The FINALLY block' below.
	The address x indicates the entry point of the finally handler.
	The finally handler should end with an END

    END,n	    - | ?
	Pops all blocks up to and including the nth block, invoking their
	end behaviours in sequence. The virtual machine is terminated
	on an END,0 instruction.

	Conceptually, the END instruction pops one block, and then
	returns control to itself (i.e. the PC does not advance) until the
	block stack height is smaller than n.


Block behaviour
===============

The WITH block

    A WITH block is created with the S.WITH instruction. 

    When this block is created, it records the state of the scope chain
    before the scope insertion of the S.WITH instruction.

    When this block is ended, it restores the scope chain.
    There is no other side-effect.

The ENUM block

    An ENUM block is created with the S.ENUM instruction. 
    It affects only the way the B.ENUM branch instruction works.
    It records the value of the E register before it is changed
    by the S.ENUM instruction.

    When this block is ended, it restores the E register.
    There is no other side-effect.

The CATCH block

    A CATCH block is created with the S.TRYC instruction. It initialises
    a SEE_TRY context.

    When a CATCH block is ended, it is removed from the block stack, and
    the SEE_TRY context is finalized. There is no other side-effect.

    If an exception occurs within the context, the following steps happen:

	- the SEE_TRY context is finalized.
	- the value stack is truncated to its length at the time of S.TRYC
	- a new Object is created, with a property set to the caught exception
	  value. This object is inserted at the front of the scope chain.
	- the CATCH block is replaced by a WITH block
	- control is passed to the address given to the S.TRYC instruction

    Note that the catch handler should end the WITH block with an END,n 
    instruction and then explicitly pass control to after the try-catch block.

The FINALLY block

    A FINALLY block is created with the S.TRYF instruction. It initialises
    a SEE_TRY context.

    When a FINALLY block is ended, the following steps happen:

	- the SEE_TRY context is finalised.
	- the value stack is truncated to its length at the time of S.TRYF
	- the FINALLY block is replaced with a FINALLY2 block
	- the PC of the END instruction is stored in the FINALLY2 block
	- control is passed to the finally handler.

    When an exception occurs inside a FINALLY block context, the
    same steps occur, except that instead of a PC, a flag is recorded in 
    the FINALLY2 block to indicate that an exception was caught and it
    should be re-thrown.

    Note that the finally handler should end with an END,n instruction
    that will direct flow of control elsewhere. (See below)

The FINALLY2 block

    A FINALLY2 block is created only when a FINALLY block is ended.
    When the FINALLY2 block is ended, the following steps happen:
	- if an exception was recorded as caught, then it is rethrown
	  as if SEE_DEFAULT_CATCH() were called
	- otherwise, flow of control is returned to the PC stored previously.
	  (this will cause the triggering END instruction to be re-executed).

