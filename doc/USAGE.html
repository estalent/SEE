<html>

<head>
<title>Using the Simple ECMAScript Engine</title>
<style type="text/css"><!--
        body     { background: white; color: black; }
        h1,h2,h3 { font-family: sans-serif; }
        h2, h3   { background: #f0f0f0; }
        table    { display: block; 
                   float: none;
                   position: relative; 
                   left: 10%; 
		   width: 80%; }
        table    { border: thin solid black;
                   border-collapse: collapse;
                   }
        table th { background: #f0f0f0;
                   border-bottom: thin solid black; }
        table th, table td { 
                   border-right: thin solid black;
                   vertical-align: top;
                 }
        td       { padding-left: 1ex; padding-right: 1ex;
		   padding-top: 0.3ex; padding-bottom: 0.3ex;
		   }
        dl       { margin-left: 4ex; }
        pre      { margin-left: 8ex; }
        code i, pre i    { color: blue; }
        code b, pre b    { color: red; }
        ul.toc   { font-size: x-small; }
        code     { white-space: nowrap; }
        /* code,pre { background: #ffe0e0; } */
        /* code.js,pre.js { background: #e0ffe0; } */
        code.js  { font-family: sans-serif; }
        code dfn,pre dfn { font: bold; color: green; }
        pre.js   { font-family: sans-serif; }
        p.misc   { font-size: x-small; color: gray; }
        ul.misc li { font-size: x-small; color: gray; }
        blockquote { font-size: x-small; }
        p.note   { margin-left: 2ex; font-size: x-small; }
        dt       { font: bold; }
	table.index { border: none }
	table.index td { font: xx-small monospace; }
// -->
</style>

</head>

<body>

<h1>Using SEE, the Simple ECMAScript Engine</h1>

<p>
by David Leonard, 2004.
</p>

<h2 id="toc">Table of contents</h2>

<ul class="toc">
<li><a href="#intro">Introduction</a>
<li><a href="#req">1 Requirements</a>
<li><a href="#interp">2 Creating interpreters</a>
<li><a href="#mem">3 Memory management</a>
 <ul>
 <li><a href="#mem2">3.1 On memory allocators</a>
 </ul>
<li><a href="#eval">4 Running programs</a>
 <ul>
 <li><a href="#runxmp">4.1 Example</a>
 <li><a href="#input">4.2 Inputs</a>
 <li><a href="#try">4.3 Try-catch contexts</a>
 </ul>
<li><a href="#value">5 Values</a>
 <ul>
 <li><a href="#conversion">5.1 Value conversion</a>
 <li><a href="#undef">5.2 Undefined, null, boolean and number values</a>
 <li><a href="#string">5.3 String values</a>
  <ul>
  <li><a href="#intern">5.3.1 Internalised strings</a>
  <li><a href="#staticstr">5.3.2 Statically initialised strings</a>
  </ul>
 </ul>
<li><a href="#object">6 Objects</a>
 <ul>
 <li><a href="#objclient">6.1 Object values, and the object client interface</a>
 <li><a href="#enum">6.2 Property enumerators</a>
 <li><a href="#objimpl">6.3 The object implementation interface</a>
 <li><a href="#native">6.4 Native objects</a>
 <li><a href="#cfunction">6.5 C function objects</a>
 <li><a href="#function">6.6 User function objects</a>
 <li><a href="#error">6.7 Errors and Error objects</a>
 </ul>
 <li><a href="#compat">7 Compatibility features</a>
 <li><a href="#debug">8 Debugging facilities</a>
 <li><a href="#ref">References</a>
 <li><a href="#idx">Name index</a>
</ul>

<h2 id="intro">Introduction</h2>

<p>
The Simple ECMAScript Engine ('SEE') is a parser and runtime library 
for the popular ECMAScript language.
ECMAScript is the official name for what most people call JavaScript:
</p>

<blockquote>
[ECMAscript] is based on several originating technologies, the most well
known being JavaScript (Netscape) and JScript (Microsoft). The language
was invented by Brendan Eich at Netscape and first appeared in that
company's Navigator 2.0 browser. It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0. 
(<a href="#ref-ecma">ECMA-262 standard</a>, 1999)
</blockquote>

<p>
SEE [almost] fully complies with ECMAScript Edition 3,
and to JavaScript 1.5.
It has "compatibility modes" that allow it to run scripts
developed under earlier versions of JavaScript, Microsoft's JScript and
LiveScript.
</p>

<p class="note">
&#9888; Note:
At the time of writing, the only non-compliant feature of SEE is with its
behaviour of <code class="js">String.toLowerCase()</code> and
<code class="js">String.toUpperCase()</code> for characters in the
non-ASCII range of Unicode.
</p>

<p>
This documentation is intended for developers wishing to incorporate
SEE into their applications. It explains how you can use SEE to:
</p>

<ul>
 <li>     manage multiple, separate ECMAScript runtime environments,
 <li>     evaluate instances of user-supplied ECMAScript program text, and
 <li>     expose your application's objects to those programs.
</ul>

<p>
This documentation does not explain the ECMAScript language,
nor discuss how to build the library on your system.
</p>

<p>
SEE includes an example application, called <i>see-shell</i> which
allows interactive use of the interpreter, and demonstrates how to
write host function objects.
</p>

<h3 id="type">Document conventions</h3>

<p>
I will use the phrase "host application" to mean your application, or
any application that uses the SEE runtime environment auxillary to
some primary purpose.
Examples of a host application are web browsers and
scriptable XML processors.
</p>

<p>
Throughout this documentation, references are made to the C functions and
macros provided by the SEE library. To avoid definitional redundancy and 
to improve precision, the reader is encouraged to examine the SEE header 
files to find the precise definitions and arguments of each function or macro.
Signatures for C macros are given, but you should understand that the compiler
cannot normally typecheck your use of those macros.
</p>

<p>Where literal C code is used, it is typeset in a monospace font, 
like this:</p>
<pre>if (failed) { abort(); }</pre>
<p>Similarly, ECMAScript code is typeset in a sans serif font, like this:</p>
<pre class="js">window.location = "about:blank";</pre>

<p>Elided code is indicated with an elipsis: <code><i>...</i></code></p>

<h2 id="req">1 Requirements</h2>

<p>
Compiling SEE requires an ANSI C compiler.
Although the SEE library is essentially self-contained, it does depend on you
(the host application developer) providing the following:
</p>

<dl>
 <dt>an IEEE 754 floating point type</dt> 
 <dd>Most modern compilers have this, but if you are developing
      for some obscure architecture, you should check.</dd>
 <dt>a garbage-collecting memory allocator</dt>
 <dd>The free <a href="#ref-boehm">Boehm gc</a> is highly recommended
      (See also <a href="#mem">&sect;3.1</a>).</dd>
</dl>

<p>
SEE uses scripts from GNU autoconf to determine if these
are available, and also to determine other system-dependent
properties. 
Host applications should <code>#include &lt;see/see.h&gt;</code> to
access all the macros and functions prototypes.
</p>

<p>
(As a developer you may find the need to edit header files and configure
scripts to make SEE compile on your system. 
I would be interested in hearing what
changes were needed so that future releases can supply this automatically
for other users. Please send mail to <a href="mailto:leonard&#64;users.sourceforge.net.nospam">leonard&#64;users.sourceforge.net.nospam</a>.)
</p>

<h2 id="interp">2 Creating interpreters</h2>

<p>
The first step in executing ECMAScript program text with SEE is to create
yourself an <em>interpreter</em> instance. 
Each interpreter represents a reusable execution context. When created,
they are initialised with all the standard ECMAScript objects
(such as <code class="js">Math</code> and <code=class="js">String</code>).
</p>

<p>
First, have your application allocate storage for a 
<code>SEE_interpreter</code> structure and then call
<code>SEE_interpreter_init()</code> to initialise that structure.
</p>

<pre>void <dfn id="SEE_interpreter_init">SEE_interpreter_init</dfn>(struct SEE_interpreter *interp);</pre>

<p>
A pointer to the initialised <code>SEE_interpreter</code> structure 
is required for almost every function that SEE provides.
</p>

<p>
SEE supports multiple independent interpreter instances.
This is useful,
for example, in an HTML web browser application, where each window may
need its own interpreter instance because the variables
and bindings to built-in objects must be different and separate in each one.
</p>

<p>
SEE's functions are not inherently thread-safe,
but multiple different interpreters can be safely used by
different threads. 
This is because all data used by the library is attached to the
<code>SEE_interpreter</code> structure; there are no global
data structures.
Interpreters can remain
completely independent of each other in this way if you:
</p>

<ul>
<li>never pass an object or mutable string reference from one interpreter 
    to the other, and
<li>use a thread-safe (or interpreter-dependent) memory allocator.
</ul>

<p>
Here is an example where the storage has been allocated on the stack,
and consequently the interpreter only exists until the function returns.
</p>

<pre>void
example()
{
    struct SEE_interpreter interp_storage;

    SEE_interpreter_init(&interp_storage);
    <i>/* now the interpreter is ready */</i>
}</pre>

<p>
There is no mechanism for explicitly destroying an initialised
interpreter; instead, SEE relies on the garbage collector to reclaim all
unreferenced storage. If you want finalization semantics, you will
need to arrange that yourself.
</p>

<p>
If SEE encounters an internal error (such as memory exhaustion,
memory corruption, or a bug), it calls the global function pointer
<code>SEE_abort</code>, 
passing it a pointer to the interpreter in context, and a short descriptive
message.
The <code>SEE_abort</code>
hook initially points to a wapper function that simply calls 
the C library function <code>abort()</code>. You can set the hook
early if you want to handle errors more gracefully.
Its signature is:
</p>

<pre>extern void (*<dfn id="SEE_abort">SEE_abort</dfn>)(struct SEE_interpreter *interp, const char *msg);</pre>

<h2 id="mem">3 Memory management</h2>

<p>
SEE uses a garbage collecting memory allocator.
It has global function pointers for memory allocation that the host 
application can configure.
These hooks must be set up 
before any interpreter instances are created.
</p>

<p>
SEE manages memory by calling through the following function pointers,
that you can change:
</p>

<pre>void* (*<dfn id="SEE_mem_malloc_hook">SEE_mem_malloc_hook</dfn>)(struct SEE_interpreter *interp, unsigned int size);
void  (*<dfn id="SEE_mem_free_hook">SEE_mem_free_hook</dfn>)(struct SEE_interpreter *interp, void *ptr);
void  (*<dfn id="SEE_mem_exhausted_hook">SEE_mem_exhausted_hook</dfn>)(struct SEE_interpreter *interp);</pre>

<p>
If SEE was compiled with Boehm-gc support, <code>SEE_mem_malloc_hook</code>
is initialised to point to a wrapper
around the <code>GC_malloc()</code> function.
Otherwise, it is initialised as <code>NULL</code> and your application must 
set it before use.
</p>

<p>
If you intend to hook in your own memory allocator, be aware that any of
these hooks may be called with a <code>NULL</code> argument,
indicating unknown context.
They must not throw exceptions, but may return <code>NULL</code> on failure.
</p>

<p>
Currently, <code>SEE_mem_free_hook</code> is unused,
although future versions may use it.
It should be left at its default value, NULL.
</p>

<p>
Instead of calling the hooks directly, application code should use these
three convenient macros to allocate storage:
</p>

<ul>
<li><code>SEE_NEW()</code>
- allocate structure storage in the context of an interpreter,
returning a pointer of given type
<li><code>SEE_NEW_ARRAY()</code>
- allocate storage for an array of elements of the given type
<li><code>SEE_ALLOCA()</code>
- allocate storage for an array on the stack (see <code>alloca()</code>)
</ul>

<pre>T *<dfn id="SEE_NEW">SEE_NEW</dfn>(struct SEE_interpreter *interp, type T);
T *<dfn id="SEE_NEW_ARRAY">SEE_NEW_ARRAY</dfn>(struct SEE_interpreter *interp, type T, int length);
T *<dfn id="SEE_ALLOCA">SEE_ALLOCA</dfn>(int length, type T);</pre>

<p>An usage example is:</p>
<pre>char *buffer = SEE_NEW_ARRAY(interp, char, 30);</pre>

<p>
These macros check for a memory allocation failure indicated by the
<code>SEE_mem_malloc_hook</code> returning NULL.
In this event they will 
assume an out-of-memory condition and call
the <code>SEE_mem_exhausted_hook</code>.
This hook defaults 
to a function that simply calls <code>SEE_abort</code>. 
Your application may prefer to change the <code>SEE_mem_exhausted_hook</code>
to handle this situation more gracefully.
</p>

<p>
It is worth familiarizing yourself with the macro definitions to
see what they do.
See <code>&lt;see/mem.h&gt;</code> for the definitions.
</p>

<h3 id="mem2">3.1 On memory allocators</h3>

<p>
Why is SEE so dependent on a garbage collector?
Why doesn't it use reference counting?
</p>

<p>
This subsection is a short diversion on answering this good question.
I have asked myself the same thing about other applications
that use garbage collectors.
I'll justify SEE's reliance on a garbage collector with the following
reasons:
</p>

<ul>
<li> Using a strict memory allocator 
(like <code>malloc()</code> and <code>free()</code>)
would have significantly increased the
complexity, development time, run-time performance and code size of the library.
This would in turn affect those properties of the host application. 
There are various convincing documents that explain why a garbage collector
is better a better general software engineering choice than (say) explicit
reference counting. 
(See the <a href="#ref-issues">Advantages and Disadvantages of Conservative Garbage Collection</a>.)
<li> Exceptions (<a href="#try">&sect;4.2</a>)
could not have been implemented easily with (fast)
<code>longjmp()</code>, because references on the stack would
become memory leaks or introduce too much fragile 'finaly' code.
<li> The object-prototype model of ECMAScript results in plenty of
circular references between constructor functions and instances,
and with recursive function scope chains.
A reference counting scheme would leak these.
<li> A decent garbage collectors for C is freely available (and some
good commercial ones exist, too).
They do nothing to impede development.
They can often be tuned to meet your 
application's usage patterns.
</ul>

<h2 id="eval">4 Running programs</h2>

<p>
SEE's ultimate purpose is to execute user scripts.
A full script, or a self-contained fragment of script is referred to
as ECMAScript program text.
You should execute program text using the following general
strategy:
<ol>
 <li> obtain a reference to an (initialised) <code>SEE_interpreter</code>
        (<a href="#interp">&sect;2</a>);
 <li> construct a <code>SEE_input</code> unicode character stream to 
      transport the 
      ECMAScript program text to SEE
        (<a href="#input">&sect;4.2</a>);
 <li> establish a try-catch context
        (<a href="#try">&sect;4.3</a>);
 <li> call the function <code>SEE_Global_eval()</code> to parse and
      evaluate the stream;
 <li> handle any exceptions caught in the try-catch context
        (<a href="#try">&sect;4.3</a>);
 <li> optionally examine the value result returned
        (<a href="#value">&sect;5</a>);
</ol>
</p>

<p>
The <code>SEE_Global_eval()</code> function is optionally able to
return the value associated with the last statement executed. 
In a non-interactive environment, this value is meaningless, and the
value result return pointer ('<code>res</code>') given to 
<code>SEE_Global_eval()</code> may be 
safely given as NULL.
</p>

<pre>void <dfn id="SEE_Global_eval">SEE_Global_eval</dfn>(struct SEE_interpreter *interp, 
                struct SEE_input *input, 
                struct SEE_value *res);</pre>

<p>
The program text is parsed and executed in one step with this
mechanism. If the evaluated text contains function definitions, the
function-objects created inside the interpreter will contain a
'precompiled' copy of the function text. This means it is safe
to destroy the input after it has been passed to 
<code>SEE_Global_eval()</code>.
</p>

<h3 id="runxmp">4.1 Example</h3>

<p>Although the rest of this document explains the library API in detail,
a complete, but simple example of using the SEE interpreter follows:</p>

<pre>#include &lt;see/see.h&gt;

<i>/* Simple example of using the interpreter */</i>
int
main()
{
        struct SEE_interpreter interp_storage, *interp;
        struct SEE_input *input;
        SEE_try_context_t try_ctxt;
        struct SEE_value result;
        char *program_text = "<code class="js">Math.sqrt(3 + 4 * 7) + 9</code>";

        <i>/* Initialise an interpreter */</i>
        SEE_interpreter_init(&interp_storage);
        interp = &interp_storage;

        <i>/* Create a stream to feed in the program text */</i>
        input = SEE_input_utf8(interp, program_text);

        <i>/* Establish an exception context */</i>
        SEE_TRY(interp, try_ctxt) {
                <i>/* Call the program evaluator */</i>
                SEE_Global_eval(interp, input, &result);

                <i>/* Print the result */</i>
                if (result.type == SEE_NUMBER)
                        printf("The answer is %f\n", result.u.number);
                else
                        printf("Unexpected answer\n");
        }

        SEE_INPUT_CLOSE(input);

        <i>/* Catch any exceptions */</i>
        if (SEE_CAUGHT(try_ctxt)) {
                printf("Unexpected exception\n");
        }

        exit(0);
}</pre>

<p>When this program is compiled, linked against the SEE library and
the garbage collector library, and run, it should respond with:</p>

<pre>The answer is 14.567764</pre>

<p>This works because the value of the last executed statement in the
<code>program_text</code> is stored in <code>result</code>.
Calling <code>SEE_Global_eval()</code> is essentially the same 
as using ECMAScript's built-in <code class="js">eval()</code>
function.
</p>

<h3 id="input">4.2 Inputs</h3>

<p>
SEE uses Unicode character stream sources known as 'inputs' to consume
(scan and parse) ECMAScript program text.
An input is a stream of 32-bit Unicode UCS-4 characters.
The stream is read, one character at a time, through its
'get next character' callback function.
</p>

<p>
The SEE library provides some useful stream constructors.
Each constructor create a new <code>SEE_input</code> 
structure, initialised for reading the source it is supplied.
</p>

<ul>
  <li>  <code>SEE_input_file()</code>
        - streams from a stdio <code>FILE</code> pointer, and
          understands Unicode byte-order marks in that file
  <li>  <code>SEE_input_utf8()</code>
        - streams the contents of a null-terminated <code>char</code> array, and
          assumes 7-bit ASCII or UTF-8 encoding
  <li>  <code>SEE_input_string()</code>
        - streams the contents of a <code>SEE_string</code> structure
          (which uses UTF-16 encoding, see <a href="#string">&sect;5.3</a>)
</ul>

<pre>struct SEE_input *<dfn id="SEE_input_file">SEE_input_file</dfn>(struct SEE_interpreter *interp, 
                FILE *f, const char *filename, const char *encoding);
struct SEE_input *<dfn id="SEE_input_utf8">SEE_input_utf8</dfn>(struct SEE_interpreter *interp,
                const char *s);
struct SEE_input *<dfn id="SEE_input_string">SEE_input_string</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *s);</pre>

<p>
If these constructors do not adequately meet your needs, you
are encouraged to develop your own. They're quite easy to do if a bit fiddly.
I recommend you find the source to one of the above and modify it to do what
you want.
</p>

<p>
The rest of this section describes the input API in detail, with a view
towards custom input streams.
</p>

<h4 id="inputapi">4.2.1 Input provider API</h4>

<p>
Why streams instead of strings?
SEE uses a stream API for inputs rather than (say) a 
simple UCS-4 or UTF-8 string API, because Unicode-compliant applications will 
usually have a much better understanding of the encodings they are using 
than will SEE. With only a small amount of effort, streams provide this 
flexibility while avoiding unnecessary duplication or text
storage.
</p>

<p>
Inputs are described by <code>SEE_input</code> structures. 
These are functionally similar to stdio's <code>FILE</code> type, or Java's 
<code>ByteReader</code> classes.
Except they stream fully-decoded Unicode characters.
The <code>SEE_input</code> structure is the focus of the API and maintains
the input's stream state and provides a pointer to its access (callback)
methods.
</p>

<pre><dfn id="struct_SEE_input">struct SEE_input</dfn> {
        struct SEE_inputclass *inputclass;
        SEE_boolean_t          eof;
        SEE_unicode_t          lookahead;
        <i>...</i>
};

<dfn id="struct_SEE_inputclass">struct SEE_inputclass</dfn> {
        SEE_unicode_t   (*next)(struct SEE_input *input);
        void            (*close)(struct SEE_input *input);
};</pre>

<p>
The <code>inputclass</code> member
indicates the access methods.
It is a pointer to a <code>SEE_inputclass</code> structure. This class structure
contains function pointers to the two methods <code>next()</code> and 
<code>close()</code>.
</p>

<p>
The <code>next()</code> method should advance the input pointer, update the
<code>eof</code> and <code>lookahead</code> members of the 
<code>SEE_input</code> structure, and return the old value of 
<code>lookahead</code>. 
SEE's scanner calls <code>next()</code> repeatedly, until
the <code>eof</code> member becomes true.
</p>

<p>
If the <code>next()</code> method encounters an encoding error, it should 
return <code>SEE_INPUT_BADCHAR</code> and try to recover. 
It can throw an exception if it wants to, but SEE does not attempt to 
handle that: the application or user program will receive it.
If you don't particularly care about Unicode, it is helpful to 
know that 7-bit ASCII is a direct subset of Unicode, so you can just pass 
each of your ASCII <code>char</code>s as a 32-bit <code>SEE_unicode_t</code>
masked with <code>0x7f</code>. 
(See <a href="#ref-unicode">the references</a>.)
</p>

<p>
The <code>close()</code> method should deallocate any operating system
resources acquired during the input stream's construction.
By convention, SEE will not call the <code>close()</code> method 
of any application-supplied input. The onus is on the caller to close the
inputs supplied to SEE library functions.
For this reason, you should use the 'finally' behaviour described
in <a href="#try">&sect;4.3</a> to clean up a possibly failed stream.
</p>

<p>
The <code>SEE_input</code> structure represents the current state of the
input stream.
Most importantly, the <code>lookahead</code> field must always reflect the
next character that a call to <code>next()</code> would return.
Once initialised, the <code>filename</code>, <code>first_lineno</code> and 
<code>interpreter</code> members of the <code>SEE_input</code> structure 
should not be changed. 
The <code>lookahead</code> and <code>eof</code> members 
should also be initialised before the structure is given to SEE.
</p>

<p>
You are encouraged to read the source code to the three constructors
listed at the beginning of this section.
</p>

<h4 id="inputapic">4.2.2 Input client API</h4>

<p>Callers will use these convenience macros to call input methods on a
constructed input stream, rather than calling through the class structure
directly:</p>

<ul>
<li><code>SEE_INPUT_NEXT()</code> -
    Consumes and returns the next Unicode character from the stream
<li><code>SEE_INPUT_CLOSE()</code> -
    Releases any resources obtained by the stream
</ul>

<pre>SEE_unicode_t <dfn id="SEE_INPUT_NEXT">SEE_INPUT_NEXT</dfn>(struct SEE_input *input);
void <dfn id="SEE_INPUT_CLOSE">SEE_INPUT_CLOSE</dfn>(struct SEE_input *input);</pre>

<h3 id="try">4.3 Try-catch contexts</h3>

<p>
SEE's exceptions are implemented using C's 
<code>setjmp()</code>/<code>longjmp()</code> mechanism. SEE provides macros 
that establish a try-catch context, and test later if a try block 
terminated abnormally (i.e. due to an thrown exception). Typical code that
uses try-catch looks like this:
</p>

<pre>struct SEE_interpreter *interp;
struct SEE_value *e;
<b>SEE_try_context_t</b> c; <i>/* storage for the try-catch context */</i>

<i>...</i>

<b>SEE_TRY</b>(interp, c) {

        <i>/*
         * Now inside a protected "try block".
         * The following calls may throw exceptions if they want,
         * causing the try block to exit immediately.
         */</i>
        do_something();
        do_something_else();

        <i>/* 
         * Because the SEE_TRY macro expands into a 'for' loop,
         * avoid using 'break', or 'return' statements.
         * If you must leave the try block, use 'continue;',
         * or throw an exception.
         */</i>
}

<i>/* Code placed here always runs. */</i>
do_cleanup();

if ((e = <b>SEE_CAUGHT</b>(c))) {
        <i>/* Handle the thrown exception 'e', somehow. */</i>
        handle_exception(e);

        <i>/* or you can throw it up to the next try-catch like so: */</i>
        <b>SEE_THROW</b>(interp, e);
}

<i>...</i></pre>

<p>
Do <strong>not</strong> <code>return</code>, <code>goto</code> or 
<code>break</code> out of a try block; the macro does not check for this, 
and the try-catch context may not be restored properly, causing all sorts of
havoc.
</p>

<p>
Exceptions thrown outside of any try-catch context will cause the
interpreter to abort.
</p>

<p>
If you are not interested in catching exceptions, and only want the
'finally' behaviour, use the following idiom:
</p>

<pre><b>SEE_TRY</b>(interp, c) {
        do_something();
}
do_finally();    <i>/* optional */</i>
<b>SEE_DEFAULT_CATCH</b>(interp, c);</pre>

<p>The signatures of these macros are:</p>

<pre><dfn id="SEE_TRY">SEE_TRY</dfn>(struct SEE_interpreter *interp, SEE_try_context_t ctxt) { <i>stmt...</i> }
struct SEE_object *<dfn id="SEE_CAUGHT">SEE_CAUGHT</dfn>(SEE_try_context_t ctxt);
void <dfn id="SEE_THROW">SEE_THROW</dfn>(struct SEE_interpreter *interp, struct SEE_object *exception);
void <dfn id="SEE_DEFAULT_CATCH">SEE_DEFAULT_CATCH</dfn>(struct SEE_interpreter *interp, SEE_try_context_t ctxt);</pre>

<h2 id="value">5 Values</h2>

<p>
Eventually, your host application will want to pass numbers, strings and 
complex value objects about, through the SEE interpreter, to and from the user
code. This section describes the C interface to ECMAScript values.</p>

<p>
The ECMAScript language has exactly six types of value. They are:
</p>

<ul>
<li><em>undefined type</em>
- with exactly one value: <code class=js>undefined</code>
<li><em>null type</em>
- with exactly one value: <code class=js>null</code>
<li><em>boolean type</em>
- with exactly two values: <code class=js>true</code>
and <code class=js>false</code>
<li><em>number type</em>
- IEEE 754 64-bit floating point numbers
<li><em>string type</em>
- UTF-16 character arrays of arbitrary length
<li><em>object type</em>
- a reference to a bag of named properties
</ul>

<p>
The <code>SEE_value</code> structure can represent values of all of
these types.
</p>

<pre><dfn id="struct_SEE_value">struct SEE_value</dfn> {
    enum { <i>...</i> }            type;
    union {
        SEE_boolean_t       boolean;
        SEE_number_t        number;
        struct SEE_string * string;
        struct SEE_object * object;
        <i>...</i>
    } u;
};</pre>

<p>
The first member, <code>type</code>, is the discriminator,
and must be one of the enumerated values
<code>SEE_UNDEFINED</code>, <code>SEE_NULL</code>, 
<code>SEE_BOOLEAN</code>, <code>SEE_NUMBER</code>, <code>SEE_STRING</code> or
<code>SEE_OBJECT</code>.
</p>

<p>
Depending on the type,
you can directly access the corresponding value of a 
<code>SEE_value</code>.
If the value variable is declared as:
</p>

<pre>struct SEE_value v;</pre>

<p>then the value that it holds is directly accessed through
its union member, <code>v.u</code>.
The following table shows which union fields of <code>v.u</code> are valid when:
</p>

<table>
<thead>
<tr>    <th><code>v.type</code></th>
        <th>Valid member</th>
        <th>Member's type</th>  </tr>
</thead>
<tbody>
<tr>    <td><code>SEE_UNDEFINED</code></td>
        <td>n/a</td>                                    </tr>
<tr>    <td><code>SEE_NULL</code></td>
        <td>n/a</td>                                    </tr>
<tr>    <td><code>SEE_BOOLEAN</code></td>
        <td><code>v.u.boolean</code></td>
        <td><code>SEE_boolean_t</code></td>             </tr>
<tr>    <td><code>SEE_NUMBER</code></td>
        <td><code>v.u.number</code></td>
        <td><code>SEE_number_t</code></td>              </tr>
<tr>    <td><code>SEE_STRING</code></td>
        <td><code>v.u.string</code></td>
        <td><code>struct SEE_string *</code></td>       </tr>
<tr>    <td><code>SEE_OBJECT</code></td>
        <td><code>v.u.object</code></td>
        <td><code>struct SEE_object *</code></td>       </tr>
</tbody></table>

<p>
Two other types (<code>SEE_COMPLETION</code> and <code>SEE_REFERENCE</code>)
are only used internally to SEE and are not documented here.
</p>

<p>
To convert/coerce values into values of a different types, use the 
utility functions describe in <a href="#conversion">&sect;5.1</a>.
</p>

<p>
To create new values in <code>struct SEE_value</code> structures, 
use the following initialisation macros. They first set the <code>type</code> 
field and then copy the second parameter into the appropriate union field.
It is fine to use a local variable for a <code>struct SEE_value</code>,
because the garbage collector can see what is being used from the stack.
</p>

<pre>void <dfn id="SEE_SET_UNDEFINED">SEE_SET_UNDEFINED</dfn>(struct SEE_value *val);
void <dfn id="SEE_SET_NULL">SEE_SET_NULL</dfn>(struct SEE_value *val);
void <dfn id="SEE_SET_OBJECT">SEE_SET_OBJECT</dfn>(struct SEE_value *val, struct SEE_object *obj);
void <dfn id="SEE_SET_STRING">SEE_SET_STRING</dfn>(struct SEE_value *val, struct SEE_string *str);
void <dfn id="SEE_SET_NUMBER">SEE_SET_NUMBER</dfn>(struct SEE_value *val, SEE_number_t num);
void <dfn id="SEE_SET_BOOLEAN">SEE_SET_BOOLEAN</dfn>(struct SEE_value *val, SEE_boolean_t bool);</pre>

<p>
Most <code>SEE_value</code>s are passed about the SEE library functions using 
pointers. This is because the general contract is that the caller supplies
storage for the return value (usually named <code>ret</code>), while
other pointer arguments are treated as read-only.
Conventionally, the result value pointer is provided as the last argument 
to these functions and is named <code>res</code>.
</p>

<p class="note">
&#9888; Note:
The <code>SEE_VALUE_COPY()</code> macro breaks this convention
by instead following the better-known idiom of <code>memcpy()</code>, and
placing the destination first.
</p>

<p>
Avoid <em>storing</em> a <code>struct SEE_value</code> as a pointer.
Instead, extract and copy values into storage using the following macro:
</p>

<pre>void <dfn id="SEE_VALUE_COPY">SEE_VALUE_COPY</dfn>(struct SEE_value *dst, struct SEE_value *src);</pre>

<p>
A simple pitfall to avoid when passing values to SEE functions is to
use value storage as both a parameter to the function and as the return result
storage.
Do not do this.
It is possible that the function will initialise its return storage before it
accesses its parameters.
</p>

<h3 id="conversion">5.1 Value conversion</h3>

<p>
The ECMAScript language specification provides for conversion functions
that the host application developer may find useful. They convert arbitrary
values into values of a known type:
</p>

<ul>
<li><code>SEE_ToPrimitive()</code>
    - Returns a non-object value. It calls the
        object's <code>DefaultValue()</code> method
        (see <a href="#objimpl">&sect;6.3</a>)
<li><code>SEE_ToBoolean()</code>
    - Returns a value of type <code>SEE_BOOLEAN</code>
<li><code>SEE_ToNumber()</code>
    - Returns a value of type <code>SEE_NUMBER</code>
<li><code>SEE_ToInteger()</code>
    - Returns a value of type <code>SEE_NUMBER</code>
        that is also a finite integer
<li><code>SEE_ToString()</code>
    - Returns a value of type <code>SEE_STRING</code>
<li><code>SEE_ToObject()</code>
    - Returns a value of type <code>SEE_OBJECT</code>
        using the <code class=js>String</code>, 
        <code class=js>Number</code> and
        <code class=js>Boolean</code>
        constructors
</ul>

<pre>void <dfn id="SEE_ToPrimitive">SEE_ToPrimitive</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *hint,
                struct SEE_value *res);
void <dfn id="SEE_ToBoolean">SEE_ToBoolean</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *res);
void <dfn id="SEE_ToNumber">SEE_ToNumber</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *res);
void <dfn id="SEE_ToInteger">SEE_ToInteger</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *res);
void <dfn id="SEE_ToString">SEE_ToString</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *res);
void <dfn id="SEE_ToObject">SEE_ToObject</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *res);</pre>

<h3 id="undef">5.2 Undefined, null, boolean and number values</h3>

<p>
The undefined and null types have exactly one implied value each, namely
<code class=js>undefined</code> and <code class=js>null</code>. 
</p>

<p class="note">
&#9888; Note:
<code class=js>null</code> is <em>not</em> an object type, and is
not related to C's <code>NULL</code> constant.
</p>

<p>
Boolean types (<code>SEE_boolean_t</code>) have values of either true (non-zero) or false (zero). 
</p>

<p>
Number values (<code>SEE_number_t</code>) are IEEE 754 signed floating 
point numbers, normally corresponding to the C compiler's built-in
<code>double</code> type.
</p>

<p>
The following macros may be used to find information about a number value.
(They assume that the <code>type</code> is <code>SEE_NUMBER</code>):
</p>

<ul>
<li><code>SEE_NUMBER_ISNAN()</code>  - return true if the number is not finite or real
<li><code>SEE_NUMBER_ISPINF()</code> - return true if number is +&infin;
<li><code>SEE_NUMBER_ISNINF()</code> - return true if number is -&infin;
<li><code>SEE_NUMBER_ISINF()</code>  - return true if number is &plusmn;&infin;
<li><code>SEE_NUMBER_ISFINITE()</code> - number is not one of the above
</ul>

<pre>int <dfn id="SEE_NUMBER_ISNAN">SEE_NUMBER_ISNAN</dfn>(struct SEE_value *val);
int <dfn id="SEE_NUMBER_ISPINF">SEE_NUMBER_ISPINF</dfn>(struct SEE_value *val);
int <dfn id="SEE_NUMBER_ISNINF">SEE_NUMBER_ISNINF</dfn>(struct SEE_value *val);
int <dfn id="SEE_NUMBER_ISINF">SEE_NUMBER_ISINF</dfn>(struct SEE_value *val);
int <dfn id="SEE_NUMBER_ISFINITE">SEE_NUMBER_ISFINITE</dfn>(struct SEE_value *val);</pre>

<p>
SEE also provides constants <code>SEE_Infinity</code> and <code>SEE_NaN</code>
which may be stored in number values, but should not be used to compare
number values. Use the macros mentioned previously, instead.
</p>

<p>
Numbers (and other values) may be converted to integers using the functions
<code>SEE_ToInt32()</code>, <code>SEE_ToUint32()</code> or 
<code>SEE_ToUint16()</code>.
</p>

<pre>SEE_int32_t <dfn id="SEE_ToInt32">SEE_ToInt32</dfn>(struct SEE_interpreter *interp, struct SEE_value *val);
SEE_uint32_t <dfn id="SEE_ToUint32">SEE_ToUint32</dfn>(struct SEE_interpreter *interp, struct SEE_value *val);
SEE_uint16_t <dfn id="SEE_ToUint16">SEE_ToUint16</dfn>(struct SEE_interpreter *interp, struct SEE_value *val);</pre>

<p>
SEE provides three data types
for integers:
</p>

<ul>
  <li> <code>SEE_uint16_t</code>        - 16 bit unsigned integer
  <li> <code>SEE_uint32_t</code>        - 32 bit unsigned integer
  <li> <code>SEE_int32_t</code>         - 32 bit signed integer
</ul>

<h3 id="string">5.3 String values</h3>

<p>
String values are pointers to <code>SEE_string</code> structures, 
that hold UTF-16 strings.
The structure is defined something like this:
</p>

<pre><dfn id="struct_SEE_string">struct SEE_string</dfn> {
        unsigned int     length;
        SEE_char_t      *data;
        <i>...</i>
};</pre>

<p>The useful members are:</p>

<ul>
<li><code>length</code>
- Length of string content
<li><code>data</code>
- Read-only storage for the string content (UTF-16 characters)
</ul>

<p>
Be aware that other strings may come to share the string's data, such
as by forming substrings. 
A string's content must not be modified after construction because of this
risk. However, the <code>length</code>
field of a string may be changed to a <strong>smaller</strong> value
at any time without concern.
</p>

<p>
The <code>SEE_char_t</code> type represents each Unicode character in the
string.  It is equivalent to a 16-bit unsigned integer.
</p>

<p>
To manipulate a string, first create a new string using one of the following:
</p>

<ul>    
  <li><code>SEE_string_new()</code> - create a new, empty string
  <li><code>SEE_string_dup()</code> - create a new string with duplicate content
  <li><code>SEE_string_concat()</code> - create a new string by duplicating 
        two other strings
  <li><code>SEE_string_sprintf()</code> - create a new string using 
        <code>printf</code>-like arguments (forced to 7-bit ASCII)
  <li><code>SEE_string_vsprintf()</code> - create a new string using
        <code>vprintf</code>-like arguments (forced to 7-bit ASCII)
</ul>

<pre>struct SEE_string *<dfn id="SEE_string_new">SEE_string_new</dfn>(struct SEE_interpreter *interp,
                unsigned int space);
struct SEE_string *<dfn id="SEE_string_dup">SEE_string_dup</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *s);
struct SEE_string *<dfn id="SEE_string_concat">SEE_string_concat</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *s1, struct SEE_string *s2);
struct SEE_string *<dfn id="SEE_string_sprintf">SEE_string_sprintf</dfn>(struct SEE_interpreter *interp,
                const char *fmt, ...);
struct SEE_string *<dfn id="SEE_string_vsprintf">SEE_string_vsprintf</dfn>(struct SEE_interpreter *interp,
                const char *fmt, va_list ap);</pre>

<p>
And then, before passing your new string to any other function, append 
characters to it using the following:
</p>

<ul>
  <li><code>SEE_string_addch()</code> - append a UTF-16 character
  <li><code>SEE_string_append()</code> - append contents of another string
  <li><code>SEE_string_append_int()</code> - append a signed integer's
                                                representation in base 10
</ul>

<pre>void <dfn id="SEE_string_addch">SEE_string_addch</dfn>(struct SEE_string *s, SEE_char_t ch);
void <dfn id="SEE_string_append">SEE_string_append</dfn>(struct SEE_string *s, const struct SEE_string *sffx);
void <dfn id="SEE_string_append_int">SEE_string_append_int</dfn>(struct SEE_string *s, int i);</pre>

<p>
Once a new string has been passed to any other SEE function, it is generally
unwise to modify its contents in any way.
It is OK to share a string
between different interpreters if the string is guaranteed not to be
modified, and the garbage collector can cope with it.
</p>

<p>
All strings in SEE use UTF-16 encoding, meaning that in some cases
you may need to be aware of Unicode 'surrogate' characters. If the host
application really needs UCS-4 strings (which is subtly different to UTF-16),
you will need to write your own converter function. Use the implementation of 
<code>SEE_input_string()</code> (<a href="#input">&sect;4.2</a>) as 
the basis for such a converter.
</p>

<p class="note">
&#9888; Note:
The <code>SEE_string_sprintf()</code> and
<code>SEE_string_vsprintf()</code> functions only generate Unicode
characters that lie in the 7-bit ASCII subset of Unicode.
</p>

<p>
Other string functions provided are:
</p>

<ul>
 <li><code>SEE_string_substr()</code> 
        - create a read-only substring string
 <li><code>SEE_string_literal()</code>  
        - create a copy of the string, escaping chars and
          enclosing it in double quotes (<code>"</code>)
 <li><code>SEE_string_fputs()</code>    
        - output the string to the stdio file using UTF-8 encoding,
	  returns <code>EOF</code> on error
 <li><code>SEE_string_cmp()</code>      
        - compares two strings, like <code>strcmp()</code>
</ul>

<pre>struct SEE_string *<dfn id="SEE_string_substr">SEE_string_substr</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *s, int index, int length);
struct SEE_string *<dfn id="SEE_string_literal">SEE_string_literal</dfn>(struct SEE_interpreter *interp,
                const struct SEE_string *s);
int <dfn id="SEE_string_fputs">SEE_string_fputs</dfn>(const struct SEE_string *s, FILE *file);
int <dfn id="SEE_string_cmp">SEE_string_cmp</dfn>(const struct SEE_string *s1,
                const struct SEE_string *s2);</pre>

<h4 id="intern">5.3.1 Internalised strings</h4>

<p>
If you find yourself comparing strings a lot, you may find it easier to
compare <em>internalised</em> strings. 
These are strings that are kept in a fast
hash table and may be compared equal using pointer equality. 
The <code>SEE_intern()</code> function returns an 'internalized' copy of the 
given string and is very fast on already-interned strings.
It is worth using in lieu of <code>SEE_string_cmp()</code> if the strings 
are likely to be intern'ed already. (For example, all property names in
the standard library are.)
</p>

<pre>struct SEE_string *<dfn id="SEE_intern">SEE_intern</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *s);</pre>

<h4 id="staticstr">5.3.2 Statically initialised strings</h4>

<p>
SEE supports statically initialised strings.
If you have a large number of strings to create and use (e.g. properties
and method names) over many interpreter instances, statically initialised
strings can save space, and improve performance.
</p>

<p>
A statically initialised string, '<code class="js">Hello, world</code>',
would look like this:
</p>

<pre><i>/* Example of a statically-initialised UTF-16 string */</i>
static SEE_char_t hello_world_chars[12] = {
    'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd'
};
static struct SEE_string hello_world = {
    12,                                                <i>/* length */</i>
    hello_world_chars                                  <i>/* data */</i>
};</pre>

<p>
The main problem with static strings is finding an elegant way
to initialise the strings' content. 
There is no simple way in ANSI C to have the compiler convert 
common ASCII strings into UTF-16 arrays.
The approach taken by SEE in supporting all the standard ECMAScript objects
and methods, is to generate C program text from a file of
ASCII strings during the build process.
</p>

<p>
If an application wishes to internalise strings <em>across interpreters</em>,
it must add all its global strings into the global
intern table before creating any interpreters. This is done by calling
<code>SEE_intern_global()</code> for each global string.
</p>

<pre>void <dfn id="SEE_intern_global">SEE_intern_global</dfn>(struct SEE_string *str);</pre>

<p>
When creating global strings, the application can either use
the static initialisation technique described above, or create
interpreter-less strings by passing a <code>NULL</code> interpreter pointer
to the various string creation functions. Such strings should be immediately
placed into the global intern table.
</p>

<h2 id="object">6 Objects</h2>

<p>
ECMAScript uses a prototype-inheritance object model with simple named
properties. More information on the object model can be found in the 
<a href="#ref-ecma">ECMA-262 standard</a>, and in other JavaScript references.
</p>

<p>
This section describes how in-memory objects can be accessed
and manipualated (the 'client interface'),
and also how host applications can expose their own application objects
and methods (the 'implementation interface').
</p>

<p>
Object instances are implemented as in-memory structures, with an 
<code>objectclass</code> pointer to a table of operational methods.
Object references are held inside values with a type field
of <code>SEE_OBJECT</code> (see <a href="#value">&sect;5</a>).
</p>

<h3 id="objclient">6.1 Object values, and the object client interface</h3>

<p>
All object values are pointers to object instances.
The pointers are of type <code>struct SEE_object *</code>.
No object pointer in a <code>SEE_value</code> should ever point to
<code>NULL</code>.
I find working with <code>struct SEE_object *</code> pointer 
types directly, instead of using <code>struct SEE_value</code> to be
convenient, when I know that I am dealing with objects.
</p>

<p>
To use an existing object instance, you should interact with it using only the
following macros:
</p>

<ul>
<li><code>SEE_OBJECT_GET()</code>
        - retrieve a named property or return <code class=js>undefined</code>
          ('<code class=js>o.prop</code>')
<li><code>SEE_OBJECT_PUT()</code>
        - create/update a named property
          ('<code class=js>o.prop = val</code>')
<li><code>SEE_OBJECT_CANPUT()</code>
        - returns true if the property can be changed
<li><code>SEE_OBJECT_HASPROPERTY()</code>
        - tests for existence of a property
<li><code>SEE_OBJECT_DELETE()</code>
        - delete a property; returns true on success 
          ('<code class=js>delete o.prop</code>')
<li><code>SEE_OBJECT_DEFAULTVALUE()</code>
        - returns the string or number value associated with the object
<li><code>SEE_OBJECT_CONSTRUCT()</code>
        - call object as a constructor
	  ('<code class=js>new o(<i>...</i>)</code>')
<li><code>SEE_OBJECT_CALL()</code>
        - call object as a function ('<code class=js>o(<i>...</i>)</code>')
<li><code>SEE_OBJECT_HASINSTANCE()</code>
        - return true if the objects are related
          ('<code class=js>x instanceof o</code>')
<li><code>SEE_OBJECT_ENUMERATOR()</code>
        - create a property enumerator
	  ('<code class=js>for (i in o) <i>...</i></code>')
</ul>

<pre>void <dfn id="SEE_OBJECT_GET">SEE_OBJECT_GET</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_string *prop,
                struct SEE_value *res);
void <dfn id="SEE_OBJECT_PUT">SEE_OBJECT_PUT</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_string *prop,
                struct SEE_value *res, int flags);
int <dfn id="SEE_OBJECT_CANPUT">SEE_OBJECT_CANPUT</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_string *prop);
int <dfn id="SEE_OBJECT_HASPROPERTY">SEE_OBJECT_HASPROPERTY</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_string *prop);
int <dfn id="SEE_OBJECT_DELETE">SEE_OBJECT_DELETE</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_string *prop);
void <dfn id="SEE_OBJECT_DEFAULTVALUE">SEE_OBJECT_DEFAULTVALUE</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_value *hint,
                struct SEE_value *res);
void <dfn id="SEE_OBJECT_CONSTRUCT">SEE_OBJECT_CONSTRUCT</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_object *thisobj,
                int argc, struct SEE_value **argv,
                struct SEE_value *res);
void <dfn id="SEE_OBJECT_CALL">SEE_OBJECT_CALL</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_object *thisobj,
                int argc, struct SEE_value **argv,
                struct SEE_value *res);
int <dfn id="SEE_OBJECT_HASINSTANCE">SEE_OBJECT_HASINSTANCE</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_value *instance);
struct SEE_enum *<dfn id="SEE_OBJECT_ENUMERATOR">SEE_OBJECT_ENUMERATOR</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj);</pre>

<p class="note">
&#9888; Note:
The last four macros (<code>SEE_OBJECT_CONSTRUCT()</code>, 
<code>SEE_OBJECT_CALL()</code>, <code>SEE_OBJECT_HASINSTANCE()</code>, 
<code>SEE_OBJECT_ENUMERATOR()</code>) 
<strong>will not check</strong> if the object 
has a <code>NULL</code> pointer for the corresponding object method.
Calling them on an
unchecked object will probably result in a memory access violation
(e.g. segmentation fault).
The following macros return true if the object safely provides 
those methods:
</p>

<ul>
<li><code>SEE_OBJECT_HAS_CALL()</code>
         - object can be called with <code>SEE_OBJECT_CALL()</code>
<li><code>SEE_OBJECT_HAS_CONSTRUCT()</code>
         - object can be called with <code>SEE_OBJECT_CONSTRUCT()</code>
<li><code>SEE_OBJECT_HAS_HASINSTANCE()</code>
         - object can be called with <code>SEE_OBJECT_HASINSTANCE()</code>
<li><code>SEE_OBJECT_HAS_ENUMERATOR()</code>
         - object can be called with <code>SEE_OBJECT_ENUMERATOR()</code>
</ul>

<pre>int <dfn id="SEE_OBJECT_HAS_CALL">SEE_OBJECT_HAS_CALL</dfn>(struct SEE_object *obj);
int <dfn id="SEE_OBJECT_HAS_CONSTRUCT">SEE_OBJECT_HAS_CONSTRUCT</dfn>(struct SEE_object *obj);
int <dfn id="SEE_OBJECT_HAS_HASINSTANCE">SEE_OBJECT_HAS_HASINSTANCE</dfn>(struct SEE_object *obj);
int <dfn id="SEE_OBJECT_HAS_ENUMERATOR">SEE_OBJECT_HAS_ENUMERATOR</dfn>(struct SEE_object *obj);</pre>

<p>
When storing properties in an object with <code>SEE_OBJECT_PUT()</code>, 
a <code>flags</code> parameter is required. 
In normal operation, this flag should be supplied as zero, but when populating
an object with its properties for the first time, the following bit
flags can be used:
</p>

<table>
<thead>
<tr><th>Flag</th>
    <th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>SEE_ATTR_READONLY</code></td>
    <td>Future assignments (puts) on this property will fail</td></tr>
<tr><td><code>SEE_ATTR_DONTENUM</code></td>
    <td>Enumerators will not list this property<br>
        and will hide inherited prototype properties of<br>
        the same name (see <a href="#enum">&sect;6.2</a>)</td></tr>
<tr><td><code>SEE_ATTR_DONTDELETE</code></td>
    <td>Future <code class=js>delete</code>s on this property will 
        fail</td></tr>
</tbody>
</table>

<h3 id="enum">6.2 Property enumerators</h3>

<p>
A property enumerator is a mechanism for discovering the properties that
an object contains. The language exercises this with its
<code class=js>for (var v in <i>...</i>)</code> construct.
The results of the enumeration need not be sorted, nor even
to be the same order each time. 
</p>

<p>
Calling <code>SEE_OBJECT_ENUMERATOR()</code> returns a 
newly created <i>enumerator</i> which is a pointer to a
<code>struct SEE_enum</code>.
Once obtained, the following macros can be used to access the enumerator:
</p>

<ul>
 <li><code>SEE_ENUM_NEXT()</code>
        - return a pointer to a property name string, or NULL 
          when the properties have been exhausted.
 <li><code>SEE_ENUM_RESET()</code>
        - rewind the enumerator to the start again
</ul>

<pre>struct SEE_string *<dfn id="SEE_ENUM_NEXT">SEE_ENUM_NEXT</dfn>(struct SEE_interpreter *interp,
                struct SEE_enum *e, int *flags_return);
void <dfn id="SEE_ENUM_RESET">SEE_ENUM_RESET</dfn>(struct SEE_interpreter *interp, struct SEE_enum *e);</pre>

<p>
Enumerators can assume that the underlying object does not change during
enumeration. 
A suggested strategy for a caller that does need to remove or add an object's
properties while enumerating them
is to first create a private list of its property names, ensuring that it
has exhausted the enumerator before attempting to modify the object.
</p>


<h3 id="objimpl">6.3 The object implementation interface</h3>

<p>
When a host application wishes to expose its own 'host objects' to 
ECMAScript programs, it must use the object implementation API
described in this section.
</p>

<p>
All SEE objects are in-memory structures starting with a 
<code>struct SEE_object</code>:
</p>

<pre><dfn id="struct_SEE_object">struct SEE_object</dfn> {
        struct SEE_objectclass *objectclass;
        struct SEE_object *     Prototype;
};</pre>

<p>
Normally, this structure is part of a larger structure that maintains the
object's private state. For example, native <code class=js>Number</code>
objects could be implemented with the following:
</p>

<pre>struct number_object {             <i>/* example implementation of Number */</i>
        struct SEE_object object;
        SEE_number_t      number;
};</pre>

<p>
Keeping the <code>object</code> part at the top of the 
<code>number_object</code> structure means that pointers of type
<code>struct number_object *</code> can be cast to and from pointers of type
<code>struct SEE_object *</code>. This is a general idiom: begin all
host object structures with a field member of type
<code>struct SEE_object</code> named <code>object</code>.
</p>

<p>
Although the ECMAScript language does not use classes <i>per se</i>,
SEE's internal object implementation does use a class 'abstraction'
to speed up execution and make implementation re-use easier.
Each object has a field, <code>object.objectclass</code>, that must
be initialised to point to a <code>struct SEE_objectclass</code> that 
provides the object's behaviour. The class structure looks like this:
</p>

<pre><dfn id="struct_SEE_objectclass">struct SEE_objectclass</dfn> {
        struct SEE_string *     Class;          <i>/* mandatory */</i>
        SEE_get_fn_t            Get;            <i>/* mandatory */</i>
        SEE_put_fn_t            Put;            <i>/* mandatory */</i>
        SEE_boolean_fn_t        CanPut;         <i>/* mandatory */</i>
        SEE_boolean_fn_t        HasProperty;    <i>/* mandatory */</i>
        SEE_boolean_fn_t        Delete;         <i>/* mandatory */</i>
        SEE_default_fn_t        DefaultValue;   <i>/* mandatory */</i>
        SEE_enumerator_fn_t     enumerator;     <i>/* optional */</i>
        SEE_call_fn_t           Construct;      <i>/* optional */</i>
        SEE_call_fn_t           Call;           <i>/* optional */</i>
        SEE_hasinstance_fn_t    HasInstance;    <i>/* optional */</i>
};</pre>

<p>
The application generally provides this structure in static storage, as
most of its members are function pointers or strings known at compile time.
A member marked "optional" above may be set to <code>NULL</code>.
</p>

<p>
The mandatory object methods (<code>Get</code>, <code>Put</code>, etc.)
should provide the precise behaviours that SEE expects on native objects.
These behaviours are fully described in the 
ECMA-262 standard, but can be summarised in the following table:
</p>

<table>
<thead>
<tr><th>Method</th>
    <th>Behaviour</th></tr>
</thead>
<tbody>
<tr><td><code>Get</code></td>
    <td>retrieve a named property (or return <code class=js>undefined</code>)</td></tr>
<tr><td><code>Put</code></td>
    <td>create/update a named property</td></tr>
<tr><td><code>Delete</code></td>
    <td>delete a property or return 0</td></tr>
<tr><td><code>HasProperty</code></td>
    <td>returns 0 if the property doesn't exist</td></tr>
<tr><td><code>CanPut</code></td>
    <td>returns 0 if the property cannot be changed</td></tr>
<tr><td><code>DefaultValue</code></td>
    <td>turns the object into a string or number value</td></tr>
<tr><td><code>Construct</code></td>
    <td>constructs a new object; as per the
        <code class=js>new</code> keyword</td></tr>
<tr><td><code>Call</code></td>
    <td>the object has been called as a function</td></tr>
<tr><td><code>HasInstance</code></td>
    <td>returns 0 if the objects are unrelated</td></tr>
<tr><td><code>enumerator</code></td>
    <td>allow enumeration of the properties (see above)</td></tr>
</tbody>
</table>

<p>
It is up to the host application to provide storage for the properties, and
so forth. The simplest strategy is to ignore property calls to
<code>Put</code> and <code>Get</code> that are meaningless.
To this end, if the host object does not want to expend effort
supporting some of the mandatory operations, it can use the 
corresponding 'do-nothing' function(s) from this list:
</p>

<ul>
  <li><code>SEE_no_get()</code>
  <li><code>SEE_no_put()</code>
  <li><code>SEE_no_canput()</code>
  <li><code>SEE_no_hasproperty()</code>
  <li><code>SEE_no_delete()</code>
  <li><code>SEE_no_defaultvalue()</code>
  <li><code>SEE_no_enumerator()</code>
</ul>

<p>
The <code>Prototype</code> field of an object instance
can either be set to:
</p>

<ul><li>the interpreter's <code>Object_prototype</code>, 
<li>to <code>NULL</code> (meaning no prototype), or 
<li>to some other object. (Be careful to avoid a prototype cycle!)</ul>
If you choose to use <code>NULL</code>, it is recommended you provide a 
<code class=js>toString()</code> method (to help with debugging).

<p>
Once the host application has constructed its own objects that
conform to the API, they can be inserted into the 'Global object'
as object-valued properties.
</p>

<p>
The 'Global object' is an unnamed, top-level object whose sole purpose
is to 'hold' all the built-in objects, such as <code class=js>Object</code>,
<code class=js>Function</code>, <code class=js>Math</code>,
etc., as well as all user-declared global variables. The host
application can access it through the <code>Global</code> member of the
<code>SEE_interpreter</code> structure.
</p>


<h3 id="native">6.4 Native objects</h3>

<p>
SEE provides support for a special kind of object class called <em>native 
objects</em>. Native objects maintain a hash table of properties, and 
implement the mandatory methods (plus <code>enumerator</code>), and 
correctly observe the <code>Prototype</code> field.
</p>

<pre><dfn id="struct_SEE_native">struct SEE_native</dfn> {
        struct SEE_object       object;
        struct SEE_property *   properties[SEE_NATIVE_HASHLEN];
};</pre>

<p>
An application can create host objects based on native objects.
First, place a <code>struct SEE_native</code> at the beginning of a
structure:
</p>

<pre>struct some_host_object {
        struct SEE_native       native;
        int                     host_specific_info;
};</pre>

<p>
Then, use the following objects methods, either directly in the 
<code>SEE_objectclass</code> structure, or by calling them indirectly 
from method implementations:
</p>

<ul>
  <li><code>SEE_native_get()</code>
  <li><code>SEE_native_put()</code>
  <li><code>SEE_native_canput()</code>
  <li><code>SEE_native_hasproperty()</code>
  <li><code>SEE_native_delete()</code>
  <li><code>SEE_native_defaultvalue()</code>
  <li><code>SEE_native_enumerator()</code>
</ul>

<h3 id="cfunction">6.5 C function objects</h3>

<p>
The host application will likely want a particular bit of C code to be able
to be called from the runtime environment.
To do this simply requires construction of an object whose 
<code>Prototype</code> field points to
<code class=js>Function.prototype</code>,
and whose <code>objectclass</code>'s <code>Call</code> method points to a 
C function that contains the desired code.
</p>

<p>
The convenience function <code>SEE_cfunction_make()</code> performs this
construction.
It takes a pointer to the C 
function, and an integer indicating the expected number of arguments. 
(The integer becomes the function object's
<code class=js>length</code> property, which is advisory only.)
</p>

<pre>struct SEE_object *<dfn id="SEE_cfunction_make">SEE_cfunction_make</dfn>(struct SEE_interpreter *interp,
                SEE_call_fn_t func, struct SEE_string *name, int argc);</pre>

<p class="note">
&#9888; Note:
Objects returned by <code>SEE_cfunction_make()</code> should really only 
be used in the interpreter context in which they were created, but the 
current version of SEE does not check for this. (Because cfunction objects 
are essentially read-only after construction, and if memory allocation
operates independently of the interpreters, sharing cfunction objects 
across interpreters will be OK, but it is not recommended for future
portability.)
</p>

<p>
The C function must conform to the <code>SEE_call_fn_t</code> signature.
This is demonstrated below, with <code>math_sqrt()</code>, which is
the actual code behind the <code class=js>Math.sqrt</code> object:
</p>

<pre><i>/* Implementation of Math.sqrt() method */</i>
static void
math_sqrt(interp, self, thisobj, argc, argv, res)
        struct SEE_interpreter *interp;
        struct SEE_object *self, *thisobj;
        int argc;
        struct SEE_value **argv, *res;
{
        struct SEE_value v;

        if (argc == 0)
                SEE_SET_UNDEFINED(res);
        else {
                SEE_ToNumber(interp, argv[0], &v);
                SEE_SET_NUMBER(res, sqrt(v.u.number));
        }
}</pre>

<p>
<!-- from <code>SEE_OBJECT_CALL</code> -->
The arguments to this function
are described in the following table:
</p>

<table>
<thead>
<tr><th>Argument</th>
    <th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>interp</code></td>
    <td>the current interpreter context</td></tr>
<tr><td><code>self</code></td>
    <td>a pointer to the object called 
        (<code class=js>Math.sqrt</code> here)</td></tr>
<tr><td><code>thisobj</code></td>
    <td>the <code class=js>this</code> object 
        (the <code class=js>Math</code> object in this 
        case)</td></tr>
<tr><td><code>argc</code></td>
    <td>number of arguments</td></tr>
<tr><td><code>argv</code></td>
    <td>array of value pointers, of length <code>argc</code></td></tr>
<tr><td><code>res</code></td>
    <td>uninitialised value location in which to store the result</td></tr>
</tbody>
</table>

<p>
A common convention in all ECMAScript functions is that unspecified
arguments should be treated as <code class=js>undefined</code>, and
extraneous arguments should just be ignored.
If the function uses <code>thisobj</code>, 
it should check any assumptions made about, especially if it is expected
to be a host object, because method functions can easily be attached to
other objects.
</p>


<h3 id="function">6.6 User function objects</h3>

<p>
Occasionally, a host application will wish to take some user text and 
create a callable function object from it. An example of this problem is 
in attaching the JavaScript code from HTML attributes onto form 
elements of a web page.
One way to achieve this is to invoke the <code class=js>Function</code> 
constructor object with the
<code>SEE_OBJECT_CONSTRUCT()</code> macro, passing it the formal arguments
text and body text as arguments.
(See <a href="#ref-ecma">the ECMAScript standard</a> for details on the
<code class=js>Function</code> constructor.)
</p>

<p>
Another way, that is more convenient if the user text is available as 
an input stream, is to use the <code>SEE_Function_new()</code> function:
</p>

<pre>struct SEE_object *<dfn id="SEE_Function_new">SEE_Function_new</dfn>(struct SEE_interpreter *interp, 
                struct SEE_string *name, struct SEE_input *param_input, 
                struct SEE_input *body_input);</pre>

<p>
where any of the the <code>name</code>, <code>param_input</code> and
<code>body_input</code> parameters may be NULL (indicating to use the 
empty string).
</p>

<p>
The returned function object may be called with the 
<code>SEE_OBJECT_CALL()</code> macro.
</p>


<h3 id="error">6.7 Errors and Error objects</h3>

<p>
Host applications sometimes need to convey errors to ECMAScript programs.
Errors in ECMAScript are typically indicated by throwing an exception
with an object value.  The thrown objects conventionally have 
<code class=js>Error.prototype</code> somewhere in their prototype chain, 
and provide a <code class=js>message</code> and <code class=js>name</code> 
property which the <code class=js>Error.prototype</code> reads to generate
a human-readable error message.
</p>

<p>
Host applications can conveniently construct and throw error exceptions using 
the following macros:
</p>

<pre>void <dfn id="SEE_error_throw_string">SEE_error_throw_string</dfn>(struct SEE_interpreter *interp, 
                struct SEE_object *error_constructor,
                struct SEE_string *text);
void <dfn id="SEE_error_throw">SEE_error_throw</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *error_constructor,
                const char *fmt, ...);
void <dfn id="SEE_error_throw_sys">SEE_error_throw_sys</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *error_constructor,
                const char *fmt, ...);</pre>

<p>
These convenience macros construct a new error object, and throw it as an 
exception using <code>SEE_THROW()</code>.
The object thrown is given a <code class=js>message</code>
string property that reflects the rest of the arguments provided 
to the called macro.
The <code>SEE_error_throw_sys()</code> macro works like
<code>SEE_error_throw()</code> but appends a textual 
description of <code>errno</code> using <code>strerror()</code>.
</p>

<p>
The <code>error_constructor</code> argument should be one of the error 
constructor objects found in the <code>SEE_interpreter</code> structure:
</p>

<table>
<thead>
<tr><th>Member</th>
    <th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>Error</code></td>
    <td>runtime error</td></tr>
<tr><td><code>EvalError</code></td>
    <td>error in <code class=js>eval()</code></td></tr>
<tr><td><code>RangeError</code></td>
    <td>numeric argument has exceeded allowable range</td></tr>
<tr><td><code>ReferenceError</code></td>
    <td>invalid reference was detected</td></tr>
<tr><td><code>SyntaxError</code></td>
    <td>parsing error</td></tr>
<tr><td><code>TypeError</code></td>
    <td>actual type of an operand different to that expected</td></tr>
<tr><td><code>URIError</code></td>
    <td>error in a global URI handling function</td></tr>
</tbody>
</table>

<p>
A simple example:
</p>

<pre>if (something_is_wrong)
        SEE_error_throw(interp, interp->Error, "something is wrong!");</pre>

<p>
Although <code>Error</code> is usually sufficient for most errors,
host applications can create their own error constructor object with the
<code>SEE_Error_make()</code> convenience function. Only one constructor
of the same name should be created per interpreter.
</p>

<pre>struct SEE_object *<dfn id="SEE_Error_make">SEE_Error_make</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *name);</pre>

<h2 id="compat">7 Compatibility features</h2>

<p>
SEE provides backward-compatibility with earlier versions of JavaScript
and JScript.
These features ought never be used, since JavaScript program authors should be
mindful of standards.
Nevertheless, this section documents the compatibility modes that SEE supplies.
</p>

<p>
The behaviour of the SEE library is modified on a per-interpreter basis,
by passing special flags to a variant of the interpreter's initialisation
routine, <code>SEE_interpreter_init_compat()</code>. This function otherwise
behaves just like <code>SEE_interpreter_init()</code>
(see <a href="#interp">&sect;2</a>).
</p>

<pre>void <dfn id="SEE_interpreter_init_compat">SEE_interpreter_init_compat</dfn>(struct SEE_interpreter *interp,
		int flags);</pre>

<p>The <code>flags</code> parameter is a bitwise OR of the constants
described in the following table.
</p>

<p class="note">
&#9888; Note:
The following compatibility flag names may change in the future.
</p>

<table>
<tr>
<th>Flag</th>
<th>Behaviour</th>
</tr>

<tr><td><code>UTF_UNSAFE</code>
<td>Treat 'overlong' UTF-8 encodings as valid unicode characters.

<tr><td><code>UNDEFDEF</code>
<td>Don't throw a <code class="js">ReferenceError</code>
 when an undefined global property is used. 
 Instead, return the <code class="js">undefined</code> value.
 This violates step 3 of s8.7.1 of ECMA-262, but it seems
 that so many interpreters are flexible on this point.
 It was originally a JavaScript 1.5 thing I believe.

<tr><td><code>262_3B</code>
<td>
Enable optional features in ECMA-262 ed3 Appendix B:
<ul>
<li><code class="js">Date.toGMTString()</code> is defined, and made equivalent to <code class="js">toUTCString()</code>
<li><code class="js">Date.getYear()</code> and <code class="js">Date.setYear()</code> are defined.
<li>Global object has <code class="js">escape()</code> and <code class="js">unescape()</code> functions defined.
<li><code class="js">String.substr()</code> is defined
</ul>

<tr><td><code>EXT1</code>
<td>
Random, unsorted extensions, mainly relating to behaviour of older JavaScript:
<ul>
<li>	SEE's lexical analyser will recognise octal integers (i.e.
	integers starting with '0') and will throw a
	<code class="js">SyntaxError</code> if they contain 
	a non-octal digit.

<li>	Coercing native values that do not have a 
	[[DefaultValue]] internal
	property will return an object-unique string, instead of throwing
	a <code class="js">TypeError</code>.

<li>	the string representation of a bad date will return the string
	'<code class="js">Invalid Date</code>',
	instead of '<code class="js">NaN</code>'.

<li>	Calling <code class="js">Date</code> as a constructor 
	will recognise Netscape-style date strings of the 
	form '<code class="js">1/1/1999 12:30 AM</code>'.

<li>	<code class="js">Function.prototype</code> will not have a
	<code class="js">prototype</code> property of its own.

<li>	<code class="js">Function.prototype.toString()</code>
	applied to built-in functions and
	constructors (which are not function instances) will return a bogus
	do-nothing FunctionDeclaration instead of throwing a
	<code class="js">TypeError</code>.

<li>	The global object has its property [[Prototype]] property set to
	<code class="js">Object.prototype</code>,
	effectively making all its properties available to the global scope,
	but having the good side effect of allowing 
	<code class="js">toString()</code> to
	work anywhere.

<li>	Calling <code class="js">eval()</code> with a 
	<code class="js">this</code> different to the global object runs
	its contents with the scope and variable object set to
	<code class="js">this</code>
	(instead of inheriting the caller's context).

<li>	Native objects synthesize a property called
	<code class="js">__proto__</code> with the same
	value as the internal [[Prototype]] property (or null). Assignments
	to <code class="js">__proto__</code> are accepted if 
	they don't cause a cycle.

<li>	Native functions assign themselves an
	<code class="js">arguments</code>
	property when called, so that the old idiom of using
	<code class="js">f.arguments</code> inside the function 
	<code class="js">f</code> will work.

<li>	The system-generated <code class="js">arguments</code> object
	created inside a function has a default-value (a comma-separated
	string representing the arguments), instead of raising a
	<code class="js">TypeError</code>. The upshot of this is that
	<code class="js">arguments</code> can be coerced into a string.

<li>	<code class="js">Array.join(undefined)</code> uses
	the string '<code class="js">undefined</code>'
	as the join string instead of '<code class="js">,</code>'.
	However when called without arguments will still use
	'<code class="js">,</code>'. (How bizarre.)

<li>	The lexical analyser will treat the 4-character sequence
	'<code class="js">&lt;!--</code>' much like the
	'<code class="js">//</code>' comment introducer. 
	This makes it very useful for use with HTML SCRIPT tags.
<li>
	Calling an empty function will not bypass the expensive 
	process of extending the scope chain, creating an arguments 
	property etc.
</ul>

</table>

<h2 id="debug">8 Debugging facilities</h2>

<p>
The SEE library contains various debugging facilities, that are
omitted if it is compiled with the <code>NDEBUG</code> preprocessor define.
</p>

<p>
Most useful to the application developer are these two functions:
</p>

<pre>void <dfn id="SEE_PrintValue">SEE_PrintValue</dfn>(struct SEE_interpreter *interp, 
                struct SEE_value *val, FILE *file);
void <dfn id="SEE_PrintObject">SEE_PrintObject</dfn>(struct SEE_interpreter *interp, 
                struct SEE_object *obj, FILE *file);
void <dfn id="SEE_PrintString">SEE_PrintString</dfn>(struct SEE_interpreter *interp, 
                struct SEE_string *str, FILE *file);</pre>

<p>
If debugging the library itself, it is worth reading the source code to
find the debug flag variables that can be turned on by the host 
application to enable verbose traces during execution.
</p>

<p>
Defining the
<code>NDEBUG</code> preprocessor symbol when building the library
also disables (slow) internal assertions that would otherwise
help show up application misuse of the API.
</p>

<h2 id="ref">References</h2>

<ul>
<li id="ref-ecma"><a href="http://ecma-international.org/publications/files/ecma-st/Ecma-262.pdf">ECMA-262, ECMAScript language specification</a>, 3rd edition, December 1999.
<li id="ref-boehm"><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">The Boehm-Weiser garbage collection package for C and C++</a>, accessed March 2004
<li id="ref-utf16">Hoffman et al., <a href="http://www.ietf.org/rfc/rfc2781.txt">UTF-16, an encoding of ISO 10646</a> [RFC 2781], February 2000
<li id="ref-issues">Boehm, <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/issues.html">Advantages and Disadvantages of Conservative Garbage Collection</a>, accessed March 2004
<li id="ref-unicode">Unicode Inc., <a href="http://www.unicode.org/versions/enumeratedversions.html#Unicode_2_1_9">Unicode 2.1.9</a>, April 1999
</ul>

<h2 id="idx">Name index</h2>

<table class="index">
<tr>
<td>
<a href="#SEE_abort">SEE_abort</a><br>
<a href="#SEE_ALLOCA">SEE_ALLOCA</a><br>
<a href="#SEE_CAUGHT">SEE_CAUGHT</a><br>
<a href="#SEE_cfunction_make">SEE_cfunction_make</a><br>
<a href="#SEE_DEFAULT_CATCH">SEE_DEFAULT_CATCH</a><br>
<a href="#SEE_ENUM_NEXT">SEE_ENUM_NEXT</a><br>
<a href="#SEE_ENUM_RESET">SEE_ENUM_RESET</a><br>
<a href="#SEE_Error_make">SEE_Error_make</a><br>
<a href="#SEE_error_throw">SEE_error_throw</a><br>
<a href="#SEE_error_throw_string">SEE_error_throw_string</a><br>
<a href="#SEE_error_throw_sys">SEE_error_throw_sys</a><br>
<a href="#SEE_Function_new">SEE_Function_new</a><br>
<a href="#SEE_Global_eval">SEE_Global_eval</a><br>
<a href="#struct_SEE_input">SEE_input</a> struct<br>
<a href="#struct_SEE_inputclass">SEE_inputclass</a> struct<br>
<a href="#SEE_INPUT_CLOSE">SEE_INPUT_CLOSE</a><br>
<a href="#SEE_input_file">SEE_input_file</a><br>
<a href="#SEE_INPUT_NEXT">SEE_INPUT_NEXT</a><br>
<a href="#SEE_input_string">SEE_input_string</a><br>
<a href="#SEE_input_utf8">SEE_input_utf8</a><br>
<td>
<a href="#SEE_intern">SEE_intern</a><br>
<a href="#SEE_intern_global">SEE_intern_global</a><br>
<a href="#SEE_interpreter_init">SEE_interpreter_init</a><br>
<a href="#SEE_interpreter_init_compat">SEE_interpreter_init_compat</a><br>
<a href="#SEE_mem_exhausted_hook">SEE_mem_exhausted_hook</a><br>
<a href="#SEE_mem_free_hook">SEE_mem_free_hook</a><br>
<a href="#SEE_mem_malloc_hook">SEE_mem_malloc_hook</a><br>
<a href="#struct_SEE_native">SEE_native</a> struct<br>
<a href="#SEE_NEW">SEE_NEW</a><br>
<a href="#SEE_NEW_ARRAY">SEE_NEW_ARRAY</a><br>
<a href="#SEE_NUMBER_ISFINITE">SEE_NUMBER_ISFINITE</a><br>
<a href="#SEE_NUMBER_ISINF">SEE_NUMBER_ISINF</a><br>
<a href="#SEE_NUMBER_ISNAN">SEE_NUMBER_ISNAN</a><br>
<a href="#SEE_NUMBER_ISNINF">SEE_NUMBER_ISNINF</a><br>
<a href="#SEE_NUMBER_ISPINF">SEE_NUMBER_ISPINF</a><br>
<a href="#struct_SEE_object">SEE_object</a> struct<br>
<a href="#struct_SEE_objectclass">SEE_objectclass</a> struct<br>
<a href="#SEE_OBJECT_CALL">SEE_OBJECT_CALL</a><br>
<a href="#SEE_OBJECT_CANPUT">SEE_OBJECT_CANPUT</a><br>
<a href="#SEE_OBJECT_CONSTRUCT">SEE_OBJECT_CONSTRUCT</a><br>
<td>
<a href="#SEE_OBJECT_DEFAULTVALUE">SEE_OBJECT_DEFAULTVALUE</a><br>
<a href="#SEE_OBJECT_DELETE">SEE_OBJECT_DELETE</a><br>
<a href="#SEE_OBJECT_ENUMERATOR">SEE_OBJECT_ENUMERATOR</a><br>
<a href="#SEE_OBJECT_GET">SEE_OBJECT_GET</a><br>
<a href="#SEE_OBJECT_HASINSTANCE">SEE_OBJECT_HASINSTANCE</a><br>
<a href="#SEE_OBJECT_HASPROPERTY">SEE_OBJECT_HASPROPERTY</a><br>
<a href="#SEE_OBJECT_HAS_CALL">SEE_OBJECT_HAS_CALL</a><br>
<a href="#SEE_OBJECT_HAS_CONSTRUCT">SEE_OBJECT_HAS_CONSTRUCT</a><br>
<a href="#SEE_OBJECT_HAS_ENUMERATOR">SEE_OBJECT_HAS_ENUMERATOR</a><br>
<a href="#SEE_OBJECT_HAS_HASINSTANCE">SEE_OBJECT_HAS_HASINSTANCE</a><br>
<a href="#SEE_OBJECT_PUT">SEE_OBJECT_PUT</a><br>
<a href="#SEE_PrintObject">SEE_PrintObject</a><br>
<a href="#SEE_PrintString">SEE_PrintString</a><br>
<a href="#SEE_PrintValue">SEE_PrintValue</a><br>
<a href="#SEE_SET_BOOLEAN">SEE_SET_BOOLEAN</a><br>
<a href="#SEE_SET_NULL">SEE_SET_NULL</a><br>
<a href="#SEE_SET_NUMBER">SEE_SET_NUMBER</a><br>
<a href="#SEE_SET_OBJECT">SEE_SET_OBJECT</a><br>
<a href="#SEE_SET_STRING">SEE_SET_STRING</a><br>
<a href="#SEE_SET_UNDEFINED">SEE_SET_UNDEFINED</a><br>
<td>
<a href="#struct_SEE_string">SEE_string</a> struct<br>
<a href="#SEE_string_addch">SEE_string_addch</a><br>
<a href="#SEE_string_append">SEE_string_append</a><br>
<a href="#SEE_string_append_int">SEE_string_append_int</a><br>
<a href="#SEE_string_cmp">SEE_string_cmp</a><br>
<a href="#SEE_string_concat">SEE_string_concat</a><br>
<a href="#SEE_string_dup">SEE_string_dup</a><br>
<a href="#SEE_string_fputs">SEE_string_fputs</a><br>
<a href="#SEE_string_literal">SEE_string_literal</a><br>
<a href="#SEE_string_new">SEE_string_new</a><br>
<a href="#SEE_string_sprintf">SEE_string_sprintf</a><br>
<a href="#SEE_string_substr">SEE_string_substr</a><br>
<a href="#SEE_string_vsprintf">SEE_string_vsprintf</a><br>
<a href="#SEE_THROW">SEE_THROW</a><br>
<a href="#SEE_ToBoolean">SEE_ToBoolean</a><br>
<a href="#SEE_ToInt32">SEE_ToInt32</a><br>
<a href="#SEE_ToInteger">SEE_ToInteger</a><br>
<a href="#SEE_ToNumber">SEE_ToNumber</a><br>
<a href="#SEE_ToObject">SEE_ToObject</a><br>
<a href="#SEE_ToPrimitive">SEE_ToPrimitive</a><br>
<td>
<a href="#SEE_ToString">SEE_ToString</a><br>
<a href="#SEE_ToUint16">SEE_ToUint16</a><br>
<a href="#SEE_ToUint32">SEE_ToUint32</a><br>
<a href="#SEE_TRY">SEE_TRY</a><br>
<a href="#struct_SEE_value">SEE_value</a> struct<br>
<a href="#SEE_VALUE_COPY">SEE_VALUE_COPY</a><br>

</table>

<hr>
<p class="misc">
&copy; David Leonard, 2004.
This documentation may be entirely reproduced and freely distributed,
as long as this copyright notice remains intact, and either the 
distributed reproduction or translation is a complete and bona fide copy, or
the modified reproduction is subtantially the same and includes a brief
summary of the modifications made. 
</p>

<pre>$Id$</pre>

<ul class="misc">
<li>Jan 2004: clean up and more examples
<li>Mar 2004: add compatibility section, prototypes, index
</ul>

</body>
</html>
