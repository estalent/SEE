<html>

<head>
<title>Using the Simple ECMAScript Engine</title>

<style type="text/css"><!--
        body     { background: white; color: black; }
        h1,h2,h3,h4 { font-family: sans-serif; }
        h2,h3,h4   { background: #f0f0f0; }
        table    { /*display: block;  */
                   /*float: none;*/
                   /*position: relative; */
                   /* margin-left: 10%; */
                   }
        table    { border-collapse: collapse; 
                   border: none /* thin solid black */;
		   margin-left: auto;
		   margin-right: auto;
		   }
        table tr { border: thin solid black; }
        table th { background: #f0f0f0;
                   border-bottom: thin solid black; }
        table th, table td { 
                   border-right: thin solid black;
                   vertical-align: top;
                 }
        td       { padding-left: 1ex; padding-right: 1ex;
                   padding-top: 0.3ex; padding-bottom: 0.3ex;
                   }
        dl       { margin-left: 4ex; }
        pre      { margin-left: 8ex; }
        code i, pre i    { color: blue; }
        code b, pre b    { 
                   background: #ffffd0;   
                   color: #202020; 
                   font-weight: normal;
                 }
        ul.toc   { font-size: smaller; }
        code     { white-space: nowrap; }
        /* code,pre { background: #ffe0e0; } */
        /* code.js,pre.js { background: #e0ffe0; } */
        code.js  { font-family: sans-serif; }
        code.meta i { font-family: serif; color: gray; }
        code dfn,pre dfn { font: bold; color: green; }
        pre.js   { font-family: sans-serif; }
        p.misc   { font-size: smaller; color: gray; }
        ul.misc li { font-size: smaller; color: gray; }
        blockquote { font-size: smaller; }
        p.note   { margin-left: 2ex; font-size: smaller; }
        dt       { font: bold; }
        table.index { border: none }
        table.index td { font: x-small monospace; }
        cite     { font-style: italic; }
        .footnote { vertical-align: super;
                    font-size: smaller;
                    color: #008; }
// -->
</style>

</head>

<body>

<h1>Using SEE, the Simple ECMAScript Engine</h1>

<p>
by David Leonard, 2006
<br>
for SEE version 2.0
</p>


<p>The impatient may want to jump straight to the <a href="#runxmp">&sect;4.1 code example</a>.</p>

<h2 id="toc">Table of contents</h2>

<ul class="toc">
<li><a href="#intro">Introduction</a>
<li><a href="#req">1 Requirements</a>
<li><a href="#interp">2 Creating interpreters</a>
 <ul>
 <li><a href="#interp-multi">2.1 Multiple simultaneous interpreters</a>
 <li><a href="#abort">2.2 Fatal error handlers</a>
 </ul>
<li><a href="#mem">3 Memory management</a>
 <ul>
 <li><a href="#mem2">3.1 On memory allocators</a>
 <li><a href="#memother">3.2 Interacting with an external allocator</a>
 <li><a href="#memfinal">3.3 Finalization</a>
 </ul>
<li><a href="#eval">4 Running programs</a>
 <ul>
 <li><a href="#runxmp">4.1 Example</a>
 <li><a href="#input">4.2 Inputs</a>
 <li><a href="#try">4.3 Try-catch contexts</a>
 </ul>
<li><a href="#value">5 Values</a>
 <ul>
 <li><a href="#conversion">5.1 Value conversion</a>
 <li><a href="#undef">5.2 Undefined, null, boolean and number values</a>
 <li><a href="#string">5.3 String values</a>
 </ul>
<li><a href="#object">6 Objects</a>
 <ul>
 <li><a href="#objclient">6.1 Object values, and the object client interface</a>
 <li><a href="#enum">6.2 Property enumerators</a>
 <li><a href="#objimpl">6.3 The object implementation interface</a>
 <li><a href="#native">6.4 Native objects</a>
 <li><a href="#cfunction">6.5 C function objects</a>
 <li><a href="#function">6.6 User function objects</a>
 <li><a href="#error">6.7 Errors and Error objects</a>
 </ul>
 <li><a href="#modules">7 Modules</a>
 <li><a href="#compat">8 Compatibility features</a>
 <ul>
 <li><a href="#compatjs">8.1 Compatibility with other JavaScript implementations</a>
 <li><a href="#compatsee">8.2 Compatibility with previous versions of SEE</a>
 </ul>
 <li><a href="#security">9 Security</a>
 <ul>
 <li><a href="#secguide">9.1 Guidelines for using the security framework</a>
 </ul>
 <li><a href="#debug">10 Debugging facilities</a>
 <li><a href="#ref">References</a>
 <li><a href="#idx">Name index</a>
</ul>

<h2 id="intro">Introduction</h2>

<p>
The Simple ECMAScript Engine ('SEE') is a parser and runtime library 
for the popular ECMAScript language.
ECMAScript is the official name for what most people call JavaScript:
</p>

<!-- img src="http://www.itconversations.com/assets/gifs/eich.gif" 
     align=right -->

<blockquote cite="#ref-ecma">
[ECMAScript] is based on several originating technologies, the most well
known being JavaScript (Netscape) and JScript (Microsoft). The language
was invented by Brendan Eich at Netscape and first appeared in that
company's Navigator 2.0 browser. It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0. 
<cite>(<a href="#ref-ecma">ECMA-262 standard</a>, 1999)</cite>
</blockquote>

<p>
SEE fully complies with ECMAScript Edition 3,
and to JavaScript 1.5.
It has compatibility modes that allow it to run scripts
developed under earlier versions of JavaScript, Microsoft's JScript and
LiveScript.
</p>

<p>
This documentation is intended for developers wishing to incorporate
SEE into their applications. It explains how you can use SEE to:
</p>

<ul>
 <li>     manage multiple, separate ECMAScript runtime environments,
 <li>     evaluate instances of user-supplied ECMAScript program text, and
 <li>     expose your application's objects to those programs.
</ul>

<p>
This documentation does not explain the ECMAScript language,
nor discuss how to build the library on your system.
</p>

<p>
SEE includes an example application, called <i>see-shell</i> which
allows interactive use of the interpreter, and demonstrates how to
write host function objects.
</p>

<h3 id="type">Document conventions</h3>

<p>
I will use the phrase <q>host application</q> to mean your application, or
any application that uses the SEE runtime environment auxillary to
some primary purpose.
Examples of a host application are web browsers and
scriptable XML processors.
</p>

<p>
Throughout this documentation, references are made to the C functions and
macros provided by the SEE library. To avoid definitional redundancy and 
to improve precision, the reader is encouraged to examine the SEE header 
files to find the precise definitions and arguments of each function or macro.
Signatures for C macros are given, but you should understand that the compiler
cannot normally typecheck your use of those macros.
</p>

<p>Where literal C code is used, it is typeset in a monospace font, 
like this:</p>
<pre>if (failed) { abort(); } <i>/* comment */</i></pre>
<p>Similarly, ECMAScript code is typeset in a sans serif font, like this:</p>
<pre class="js">window.location = "about:blank";</pre>

<p>
Important parts of exammple code are <code><b>highlighted</b></code>, and
elided code is indicated with an elipsis, like this: <code><i>...</i></code>
</p>

<p>
Function definitions listed in the <a href="#idx">name index</a>
appear in green, like this: <code><dfn>SEE_example()</dfn></code>
</p>

<p>
The term ASCII refers to character codes in the decimal range 0 through 127,
inclusive.
</p>

<h2 id="req">1 Requirements</h2>

<p>
Compiling SEE requires an ANSI C compiler.
Although the SEE library is essentially self-contained, it does depend on you
(the host application developer) providing the following:
</p>

<dl>
 <dt>an IEEE 754 floating point type</dt> 
 <dd>Most modern compilers have this, but if you are developing
      for some obscure architecture, you should check.</dd>
 <dt>a garbage-collecting memory allocator</dt>
 <dd>The free <a href="#ref-boehm">Boehm gc</a> is highly recommended
      (See also <a href="#mem">&sect;3.1</a>).</dd>
</dl>

<p>
SEE uses scripts from GNU autoconf to determine if these
are available, and also to determine other system-dependent
properties. 
Host applications should <code>#include &lt;see/see.h&gt;</code> to
access all the macros and functions prototypes.
</p>

<p class="note">
&#9888; Note:
A future release of SEE will use IBM's ICU library for Unicode support.
</p>

<p>
(As a developer you may find the need to edit header files and configure
scripts to make SEE compile on your system. 
I would be interested in hearing what
changes were needed so that future releases can supply this automatically
for other users. Please send mail to <a href="mailto:leonard&#64;users.sourceforge.net.nospam">leonard&#64;users.sourceforge.net.nospam</a>.)
</p>

<h2 id="interp">2 Creating interpreters</h2>

<p>
The first step in executing ECMAScript program text with SEE is to create
yourself an <em>interpreter</em> instance. 
Each interpreter represents a reusable execution context. When created,
they are initialised with all the standard ECMAScript objects
(such as <code class="js">Math</code> and <code class="js">String</code>).
</p>

<p>
First, have your application allocate storage for a 
<code>SEE_interpreter</code> structure and then call
<code>SEE_interpreter_init()</code> to initialise that structure.
</p>

<pre>void <dfn id="SEE_interpreter_init">SEE_interpreter_init</dfn>(struct SEE_interpreter *interp);</pre>

<p>
A pointer to the initialised <code>SEE_interpreter</code> structure 
is required for almost every function that SEE provides.
</p>
<p>
Here is an example where the storage has been allocated on the stack,
and consequently the interpreter only exists until the function returns.
</p>

<pre>void
example()
{
    struct SEE_interpreter interp_storage;

    SEE_interpreter_init(&amp;interp_storage);
    <i>/* now the interpreter is ready */</i>
}</pre>

<p>
There is no mechanism for explicitly destroying an initialised
interpreter; instead, SEE relies on the garbage collector to reclaim all
unreferenced storage. If you want finalization semantics, you will
need to arrange that yourself.
</p>


<p class="note">
&#9888; Note:
A future release of SEE may provide hooks for host object finalisation.
</p>

<h3 id="interp-multi">2.1 Multiple simultaneous interpreters</h3>

<p>
SEE supports multiple independent interpreter instances.
This is useful,
for example, in an HTML web browser application, where each window may
need its own interpreter instance because the variables
and bindings to built-in objects must be different and separate in each one.
</p>

<p>
SEE's functions are not inherently thread-safe,
but multiple different interpreters can be safely used by
different threads. 
This is because all data used by the library is attached to the
<code>SEE_interpreter</code> structure; there are no mutable global
data structures.
Interpreters can remain
completely independent of each other in this way if you:
</p>

<ul>
<li>never pass an object or mutable string reference from one interpreter 
    to the other, and
<li>use a thread-safe (or interpreter-dependent) memory allocator.
</ul>

<h3 id="abort">2.2 Fatal error handlers</h3>

<p>
If SEE encounters an internal error (such as memory exhaustion,
memory corruption, or a bug), it calls the global function pointer
<code>SEE_system.abort</code>, 
passing it a pointer to the interpreter in context (or <code>NULL</code>),
and a short descriptive message.
The <code>SEE_system.abort</code>
hook initially points to a wapper function that simply calls 
the C library function <code>abort()</code>. You can set the hook
early if you want to handle errors more gracefully.
Its signature is:
</p>

<pre>extern struct {
    <i>...</i>
    extern void (*<dfn id="SEE_system.abort">abort</dfn>)(struct SEE_interpreter *interp, const char *msg) _SEE_dead;
    <i>...</i>
} SEE_system;</pre>

<p>
A convenience macro, <code>SEE_ABORT()</code> is provided for 
applications to call through this hook.
</p>
<pre>extern void (*<dfn id="SEE_ABORT">SEE_ABORT</dfn>)(struct SEE_interpreter *interp, const char *msg);</pre>

<h2 id="mem">3 Memory management</h2>

<p>
SEE uses a garbage collecting memory allocator.
SEE has global function pointers for memory allocation that the host 
application can configure.
These hooks must be set up 
before any interpreter instances are created.
</p>

<p>
SEE manages memory by calling through the following function pointers
stored in the global structure <code>SEE_system</code>.
Your host application can replace them before it creates
any interpreters.
</p>

<pre>extern struct {
    <i>...</i>
    void * (*<dfn id="SEE_system.malloc">malloc</dfn>)(struct SEE_interpreter *interp, SEE_size_t size);
    void * (*<dfn id="SEE_system.malloc_string">malloc_string</dfn>)(struct SEE_interpreter *interp, SEE_size_t size);
    void   (*<dfn id="SEE_system.free">free</dfn>)(struct SEE_interpreter *interp, void *ptr);
    void   (*<dfn id="SEE_system.mem_exhausted">mem_exhausted</dfn>)(struct SEE_interpreter *interp);
    void   (*<dfn id="SEE_system.gcollect">gcollect</dfn>)(struct SEE_interpreter *interp);
    <i>...</i>
} SEE_system;</pre>

<p>
These hooks are invoked through the following functions:
</p>
<ul>
<li><code>SEE_malloc()</code>
- allocate storage that is scanned during garbage collection
<li><code>SEE_malloc_string()</code>
- allocate storage for a string that will not contain pointers
<li><code>SEE_free()</code>
- release storage that you can guarantee is unreferenced from anywhere
<li><code>SEE_gcollect()</code>
- releases all unreachable objects, if possible
</ul>

<pre>void * <dfn id="SEE_malloc">SEE_malloc</dfn>(struct SEE_interpreter *interp, SEE_size_t size);
void * <dfn id="SEE_malloc_string">SEE_malloc_string</dfn>(struct SEE_interpreter *interp, SEE_size_t size);
void <dfn id="SEE_free">SEE_free</dfn>(struct SEE_interpreter *interp, void **datap);
void <dfn id="SEE_gcollect">SEE_gcollect</dfn>(struct SEE_interpreter *interp);</pre>

<p>
Notice that <code>SEE_free()</code> takes a pointer-to-a-pointer, unlike
its counterpart in the <code>SEE_system</code> structure.
The pointer will be set to <code>NULL</code> after freeing.
Freeing a <code>NULL</code> pointer with <code>SEE_free()</code> has no effect.
</p>

<p>
If SEE was compiled with Boehm-gc support, <code>SEE_system.malloc</code>
is initialised to point to a wrapper
around the <code>GC_malloc()</code> function,
<code>SEE_system.malloc_string</code> is initialised to point to a wrapper
around <code>GC_malloc_atomic()</code>, and
<code>SEE_system.free</code> is initialised to point to a wrapper
around <code>GC_free()</code>.
Otherwise, the functions will use the system <code>malloc()</code>.
</p>

<p>
If you intend to hook in your own memory allocator, be aware that any of
these hooks may be called with a <code>NULL</code> interpreter argument,
indicating unknown context.
The malloc hooks must not throw exceptions,
but should return <code>NULL</code> on failure.
</p>

<p>
Instead of calling the hooks directly, application code should use these
three convenient macros to allocate storage:
</p>

<ul>
<li><code>SEE_NEW()</code>
- allocate structure storage in the context of an interpreter,
returning a pointer of given type
<li><code>SEE_NEW_ARRAY()</code>
- allocate storage for an array of elements of the given type
<li><code>SEE_NEW_STRING_ARRAY()</code>
- a gc-efficient form of <code>SEE_NEW_ARRAY()</code>, where you guarantee that the elements will not contain pointers
<li><code>SEE_NEW_FINALIZE()</code>
- same as <code>SEE_NEW()</code>, but associates a finalizer function
<li><code>SEE_ALLOCA()</code>
- allocate storage for an array on the stack (see <code>alloca()</code>)
<li><code>SEE_STRING_ALLOCA()</code>
- like <code>SEE_ALLOCA()</code>, except used to hint that the allocated
elements will not contain pointers
</ul>

<pre>T * <dfn id="SEE_NEW">SEE_NEW</dfn>(struct SEE_interpreter *interp, type T);
T * <dfn id="SEE_NEW_ARRAY">SEE_NEW_ARRAY</dfn>(struct SEE_interpreter *interp, type T, int length);
T * <dfn id="SEE_NEW_STRING_ARRAY">SEE_NEW_STRING_ARRAY</dfn>(struct SEE_interpreter *interp, type T, int length);
T * <dfn id="SEE_NEW_FINALIZE">SEE_NEW_FINALIZE</dfn>(struct SEE_interpreter *interp, type T, void (*finalizefn)(struct SEE_interpreter *, void *, void *), void *closure);
T * <dfn id="SEE_ALLOCA">SEE_ALLOCA</dfn>(struct SEE_interpreter *interp, type T, int length);
T * <dfn id="SEE_STRING_ALLOCA">SEE_STRING_ALLOCA</dfn>(struct SEE_interpreter *interp, type T, int length);</pre>

<p>A usage example is:</p>
<pre>char *buffer = SEE_NEW_STRING_ARRAY(interp, char, 30);</pre>

<p>
These macros check for a memory allocation failure indicated by the
system allocator returning <code>NULL</code>.
In this event they will 
assume an out-of-memory condition and call
the <code>SEE_system.mem_exhausted()</code>.
This hook defaults 
to a function that simply calls <code>SEE_ABORT()</code>. 
Your application may prefer to change the <code>mem_exhausted</code>
hook to handle this situation more gracefully.
</p>

<p>
It is worth familiarizing yourself with the macro definitions to
see what they do.
See <code>&lt;see/mem.h&gt;</code> for the definitions.
</p>

<h3 id="mem2">3.1 On memory allocators</h3>

<p>
Why is SEE so dependent on a garbage collector?
Why doesn't it use reference counting?
</p>

<p>
This subsection is a short diversion on answering this good question.
I have asked myself the same thing about other applications
that use garbage collectors.
I'll justify SEE's reliance on a garbage collector with the following
reasons:
</p>

<ul>
<li> Using a strict memory allocator 
(like <code>malloc()</code> and <code>free()</code>)
would have significantly increased the
complexity, development time, run-time performance and code size of the library.
This would in turn affect those properties of the host application. 
There are various convincing documents that explain why a garbage collector
is a better general software engineering choice than (say) explicit
reference counting. 
(See <cite><a href="#ref-issues">Advantages and Disadvantages of Conservative Garbage Collection</a></cite>.)
<li> Exceptions (<a href="#try">&sect;4.2</a>)
could not have been implemented easily with (fast)
<code>longjmp()</code>, because references on the stack would
become memory leaks or introduce too much fragile 'finally' code.
<li> The object-prototype model of ECMAScript results in plenty of
circular references between constructor functions and instances,
and with recursive function scope chains.
A reference counting scheme would 
leak these
[<a href="http://www.codeproject.com/jscript/LeakPatterns.asp">1</a>]
[<a href="http://jibbering.com/faq/faq_notes/closures.html#clMem">2</a>].
<li> A decent garbage collector for C is freely available (and some
good commercial ones exist, too).
They do nothing to impede development.
They can often be tuned to meet your 
application's usage patterns.
</ul>

<h3 id="memother">3.2 Interacting with an external allocator</h3>

<p>
If you are embedding SEE in a host application that uses
<code>malloc()</code>,
any <code>struct SEE_...</code> pointers that
you keep inside storage obtained by <code>malloc()</code> 
are likely to be unreliable.
This is because garbage collectors do not normally look
inside <code>malloc</code>ed memory.
</p>

<p>
To make the GC aware of your reference to the SEE object,
you will either need to arrange for the GC to
scan your malloc'd memory (e.g. by adding it to its <q>root set</q>) or 
by using a level of pointer indirection through <q>uncollectable</q> GC
memory. 
</p>

<p>
For example, you might create an indirect reference by allocating storage
with Boehm's <code>GC_MALLOC_UNCOLLECTABLE()</code> function for
a structure like this:
</p>

<pre>struct myobjref {   <i>/* Always allocate this as GC uncollectable */</i>
    struct SEE_interpreter *interp;
    struct SEE_object *object;
}</pre>

<p>
Then, you can safely keep a pointer to the <code>myobjref</code>
in storage allocated by <code>malloc()</code>.
It would still be your problem to eventually release 
the <code>myobjref</code> with a call to <code>GC_FREE()</code>.
</p>

<p>
You may also find it convenient for SEE to manage the lifetime of your
<code>malloc</code>ed host data. 
This normally happens when you create wrapped SEE objects
(see <a href="#objimpl">&sect;6.3</a>)
and include pointers into storage allocated with
with <code>malloc()</code>.
To achieve this, use <code>SEE_NEW_FINALIZE()</code> to allocate
the wrapped object structure, and a finalizer function that calls
<code>free()</code> on the right members.
</p>

<p>
Similar approaches can be used for external allocators that use
reference counting.
</p>


<h3 id="memfinal">3.3 Finalization</h3>

<p>
Host objects that acquire operating system resources
can release those resources when their finalizer is called by the
garbage collector.
However, a major criticism of garbage collectors is that finalizers
are not invoked early or often enough.
What this means is that it is highly desirable to release system resources 
at the earliest time possible (i.e. immediately the referring object becomes
unreachable), but garbage collectors deliberately don't do this
because performing the reachability analysis on objects is expensive
and often left only to when memory is low.
</p>

<p>To address this problem,
I recommend developers follow these guidelines when designing 
their host object finalizers:</p>

<ol>
<li>
Provide a host object method 
(conventionally called <code class="js">dispose()</code>)
that immediately releases all resources acquired by the object. 
The dispose method should cope with being called multiple times without error.
The object will need to maintain state indicating whether it is valid or
disposed, and its methods should check this state and generally throw
an exception if it is invalid.
You may also wish to provide the user with an accessor for this state,
e.g. <code class="js">isValid()</code>.
The state can usually be combined with other normally occurring error 
states of the object.
</li>
<li>
Arrange to have the finalizer simply invoke the dispose method.
You may even choose to allow users to <q>hook</q> the dispose method
by having the finalizer call the method
indirectly with <code>SEE_OBJECT_CALL</code>, and then
once again, directly, in case the user's hook failed.
</li>
<li>
Detect/predict resource exhaustion at the point when host objects 
acquire new resources. In this case, force an immediate garbage collection
by calling <code>SEE_gcollect()</code>, and then
try just once more to acquire the resource before failing.
</li>
</ol>

<p>
The principal effects of these guidelines are to 
first shift the burden of optional, optimal reachability analysis
onto the user, and secondly to couple memory exhaustion with resource
exhaustion to exploit the benefits of late reachability analysis and
avoid false resource loss when memory is plentiful.
</p>

<h2 id="eval">4 Running programs</h2>

<p>
SEE's ultimate purpose is to execute user scripts.
A full script, or a self-contained fragment of a script is referred to
as <dfn>program text</dfn>.
You should execute program text using the following general
strategy:
<ol>
 <li> obtain a reference to an (initialised) <code>SEE_interpreter</code>
        (<a href="#interp">&sect;2</a>);
 <li> construct a <code>SEE_input</code> unicode stream reader 
        (<a href="#input">&sect;4.2</a>)
        to transport the 
      ECMAScript program text to SEE's parser;
 <li> establish a try-catch context
        (<a href="#try">&sect;4.3</a>);
 <li> call the function <code>SEE_Global_eval()</code> to parse and
      evaluate the stream;
 <li> handle any exceptions caught in the try-catch context
        (<a href="#try">&sect;4.3</a>);
 <li> examine the value result returned
        (<a href="#value">&sect;5</a>) (optional)
</ol>
</p>

<p>
The <code>SEE_Global_eval()</code> function is able to
execute program text and then
store the value associated with the last executed statement in 
a location given by a value pointer.
In a non-interactive environment, this last statement's value is 
usually meaningless, and the
value result return pointer ('<code>res</code>') given to 
<code>SEE_Global_eval()</code> may be 
safely given as <code>NULL</code>.
</p>

<pre>void <dfn id="SEE_Global_eval">SEE_Global_eval</dfn>(struct SEE_interpreter *interp, 
                struct SEE_input *input, 
                struct SEE_value *res);</pre>

<p>
The program text is first parsed and then executed with this
function. If the evaluated text contains function definitions, the
function-objects created inside the interpreter will contain a
'precompiled' copy of the function text. This means it is safe
to destroy the input immediately after it has been passed to 
<code>SEE_Global_eval()</code>.
</p>

<h3 id="runxmp">4.1 Example</h3>

<p>Although the rest of this document explains the library API in detail,
a complete, but simple example of using the SEE interpreter follows:</p>

<pre>#include &lt;see/see.h&gt;

<i>/* Simple example of using the interpreter */</i>
int
main()
{
        struct SEE_interpreter interp_storage, *interp;
        struct SEE_input *input;
        SEE_try_context_t try_ctxt;
        struct SEE_value result;
        char *program_text = "<code class="js">Math.sqrt(3 + 4 * 7) + 9</code>";

        <i>/* Initialise an interpreter */</i>
        SEE_interpreter_init(&amp;interp_storage);
        interp = &amp;interp_storage;

        <i>/* Create an input stream that provides program text */</i>
        input = SEE_input_utf8(interp, program_text);

        <i>/* Establish an exception context */</i>
        SEE_TRY(interp, try_ctxt) {
                <i>/* Call the program evaluator */</i>
                SEE_Global_eval(interp, input, &amp;result);

                <i>/* Print the result */</i>
                if (SEE_VALUE_GET_TYPE(&amp;result) == SEE_NUMBER)
                        printf("The answer is %f\n", result.u.number);
                else
                        printf("Unexpected answer\n");
        }

        <i>/* Finally: */</i>
        SEE_INPUT_CLOSE(input);

        <i>/* Catch any exceptions */</i>
        if (SEE_CAUGHT(try_ctxt))
                printf("Unexpected exception\n");

        exit(0);
}</pre>

<p>When this program is compiled, linked against the SEE library and
the garbage collector library, and run, it should respond with:</p>

<pre>The answer is 14.567764</pre>

<p>This works because the value of the last executed statement in the
<code>program_text</code> is stored in <code>result</code>.
Calling <code>SEE_Global_eval()</code> is essentially the same 
as using ECMAScript's built-in <code class="js">eval()</code>
function.
</p>

<p>If you are interested in developing a provider module for SEE,
then you should look at the example module file <i>shell/mod_File.c</i>.
</p>

<h3 id="input">4.2 Inputs</h3>

<p>
SEE uses Unicode character stream sources known as 'inputs' to consume
(scan and parse) ECMAScript program text.
An input is a stream of 32-bit Unicode UCS-4 characters.
The stream is read, one character at a time, through its
'get next character' callback function.
</p>

<p>
The SEE library provides some useful stream constructors.
Each constructor create a new <code>SEE_input</code> 
structure, initialised for reading the source it is supplied.
</p>

<ul>
  <li>  <code>SEE_input_file()</code>
        - streams from a stdio <code>FILE</code> pointer, and
          understands Unicode byte-order marks in that file
  <li>  <code>SEE_input_utf8()</code>
        - streams the contents of a null-terminated <code>char</code> array, and
          assumes 7-bit ASCII or UTF-8 encoding
  <li>  <code>SEE_input_string()</code>
        - streams the contents of a <code>SEE_string</code> value structure
          (which uses UTF-16 encoding, see <a href="#string">&sect;5.3</a>)
</ul>

<pre>struct SEE_input *<dfn id="SEE_input_file">SEE_input_file</dfn>(struct SEE_interpreter *interp, 
                FILE *f, const char *filename, const char *encoding);
struct SEE_input *<dfn id="SEE_input_utf8">SEE_input_utf8</dfn>(struct SEE_interpreter *interp,
                const char *s);
struct SEE_input *<dfn id="SEE_input_string">SEE_input_string</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *s);</pre>

<p>
If these constructors do not adequately meet your needs, you
are encouraged to develop your own. They're quite easy to do, if a bit fiddly.
I recommend you find the source to one of the above and modify it to do what
you want.
</p>

<p>
The rest of this section describes the input API in detail, with a view
towards custom input streams.
</p>

<h4 id="inputapi">4.2.1 Input provider API</h4>

<p>
Why streams instead of strings?
SEE uses a stream API for inputs rather than (say) a 
simple UCS-4 or UTF-8 string API, because Unicode-compliant applications will 
usually have a much better understanding of the encodings they are using 
than will SEE. With only a small amount of effort, streams provide this 
flexibility while avoiding unnecessary duplication or text
storage.
</p>

<p>
Inputs are described by <code>SEE_input</code> structures. 
These are functionally similar to stdio's <code>FILE</code> type, or Java's 
<code>ByteReader</code> classes.
Except they stream fully-decoded Unicode characters.
The <code>SEE_input</code> structure is the focus of the API and maintains
the input's stream state and provides a pointer to its access (callback)
methods.
</p>

<pre><dfn id="struct_SEE_input">struct SEE_input</dfn> {
        struct SEE_inputclass *inputclass;
        SEE_boolean_t          eof;
        SEE_unicode_t          lookahead;
        <i>...</i>
};

<dfn id="struct_SEE_inputclass">struct SEE_inputclass</dfn> {
        SEE_unicode_t   (*next)(struct SEE_input *input);
        void            (*close)(struct SEE_input *input);
};</pre>

<p>
The <code>inputclass</code> member
indicates the access methods.
It is a pointer to a <code>SEE_inputclass</code> structure. This class structure
contains function pointers to the two methods <code>next()</code> and 
<code>close()</code>.
</p>

<p>
The <code>next()</code> method should advance the input pointer, update the
<code>eof</code> and <code>lookahead</code> members of the 
<code>SEE_input</code> structure, and return the old value of 
<code>lookahead</code>. 
SEE's scanner calls <code>next()</code> repeatedly, until
the <code>eof</code> member becomes true.
When <code>eof</code> is true, the value of <code>lookahead</code> becomes
meaningless (but should be set to <code>-1</code>).
Generally, the stream's constructor will internally call its
<code>next()</code> function once initially, to 'prime' the lookahead field.
</p>

<p>
If the <code>next()</code> method encounters an encoding error, it should 
set <code>lookahead</code> to <code>SEE_INPUT_BADCHAR</code> and try to 
recover. 
It can throw an exception if it wants to, but SEE does not attempt to 
handle that: the application or user program will receive it.
If you don't particularly care about Unicode, it is helpful to 
know that 7-bit ASCII is a direct subset of Unicode, so you can just pass 
each of your ASCII <code>char</code>s as a 32-bit <code>SEE_unicode_t</code>
masked with <code>0x7f</code>. 
(See the <a href="#ref-unicode">Unicode standards</a>.)
</p>

<p>
The <code>close()</code> method should deallocate any operating system
resources acquired during the input stream's construction.
By convention, SEE will not call the <code>close()</code> method 
of any application-supplied input. The onus is on the caller to close the
inputs supplied to SEE library functions.
For this reason, you should use the 'finally' behaviour described
in <a href="#try">&sect;4.3</a> to clean up a possibly failed stream.
</p>

<p>
The <code>SEE_input</code> structure represents the current state of the
input stream.
Most importantly, the <code>lookahead</code> field must always reflect the
next character that a call to <code>next()</code> would return.
Once initialised, the <code>filename</code>, <code>first_lineno</code> and 
<code>interpreter</code> members of the <code>SEE_input</code> structure 
should not be changed. 
The <code>lookahead</code> and <code>eof</code> members 
should also be initialised before the structure is given to SEE.
</p>

<p>
You are encouraged to read the source code to the three constructors
listed at the beginning of this section.
</p>

<h4 id="inputapic">4.2.2 Input client API</h4>

<p>Callers will use these convenience macros to call input methods on a
constructed input stream, rather than calling through the class structure
directly:</p>

<ul>
<li><code>SEE_INPUT_NEXT()</code> -
    Consumes and returns the next Unicode character from the stream
<li><code>SEE_INPUT_CLOSE()</code> -
    Releases any resources obtained by the stream
</ul>

<pre>SEE_unicode_t <dfn id="SEE_INPUT_NEXT">SEE_INPUT_NEXT</dfn>(struct SEE_input *input);
void <dfn id="SEE_INPUT_CLOSE">SEE_INPUT_CLOSE</dfn>(struct SEE_input *input);</pre>

<h3 id="try">4.3 Try-catch contexts</h3>

<p>
SEE's exceptions are implemented using C's 
<code>setjmp()</code>/<code>longjmp()</code> mechanism. SEE provides macros 
that establish a try-catch context, and test later if a try block 
terminated abnormally (i.e. due to an thrown exception). Typical code that
uses try-catch looks like this:
</p>

<pre>struct SEE_interpreter *interp;
struct SEE_value *e;
<b>SEE_try_context_t</b> c; <i>/* storage for the try-catch context */</i>

<i>...</i>

<b>SEE_TRY</b>(interp, c) {

        <i>/*
         * Now inside a protected "try block".
         * The following calls may throw exceptions if they want,
         * causing the try block to exit immediately.
         */</i>
        do_something();
        do_something_else();

        <i>/* 
         * Because the SEE_TRY macro expands into a 'for' loop,
         * avoid using 'break', or 'return' statements.
         * If you must leave the try block, use 'continue;',
         * or throw an exception.
         */</i>
}

<i>/* Code placed here always runs. */</i>
do_cleanup();

if ((e = <b>SEE_CAUGHT</b>(c))) {
        <i>/* Handle the thrown exception 'e', somehow. */</i>
        handle_exception(e);

        <i>/* or you can throw it up to the next try-catch like so: */</i>
        <b>SEE_THROW</b>(interp, e);
}

<i>...</i></pre>

<p>
Do <strong>not</strong> <code>return</code>, <code>goto</code> or 
<code>break</code> out of a try block; the macro does not check for this, 
and the try-catch context may not be restored properly, causing all sorts of
havoc.
</p>

<p>
Exceptions thrown outside of any try-catch context will cause the
interpreter to abort.
</p>

<p>
If you are not interested in catching exceptions, and only want the
'finally' behaviour, use the following idiom:
</p>

<pre><b>SEE_TRY</b>(interp, c) {
        do_something();
}
do_finally();    <i>/* optional */</i>
<b>SEE_DEFAULT_CATCH</b>(interp, c);</pre>

<p>The signatures of these macros are:</p>

<pre><dfn id="SEE_TRY">SEE_TRY</dfn>(struct SEE_interpreter *interp, SEE_try_context_t ctxt) { <i>stmt...</i> }
struct SEE_object *<dfn id="SEE_CAUGHT">SEE_CAUGHT</dfn>(SEE_try_context_t ctxt);
void <dfn id="SEE_THROW">SEE_THROW</dfn>(struct SEE_interpreter *interp, struct SEE_object *exception);
void <dfn id="SEE_DEFAULT_CATCH">SEE_DEFAULT_CATCH</dfn>(struct SEE_interpreter *interp, SEE_try_context_t ctxt);</pre>

<h2 id="value">5 Values</h2>

<p>
Eventually, your host application will want to pass numbers, strings and 
complex value objects about, through the SEE interpreter, to and from the user
code. This section describes the C interface to ECMAScript values.</p>

<p>
The ECMAScript language has exactly six types of value. They are:
</p>

<ul>
<li><em>undefined type</em>
- with exactly one value: <code class="js">undefined</code>
<li><em>null type</em>
- with exactly one value: <code class="js">null</code>
<li><em>boolean type</em>
- with exactly two values: <code class="js">true</code>
and <code class="js">false</code>
<li><em>number type</em>
- IEEE 754 64-bit floating point numbers
<li><em>string type</em>
- UTF-16 character arrays of arbitrary length
<li><em>object type</em>
- a reference to a bag of named properties
</ul>

<p>
The <code>SEE_value</code> structure can represent values of all of
these types.
</p>

<pre><dfn id="struct_SEE_value">struct SEE_value</dfn> {
    enum { <i>...</i> }            _type;
    union {
        SEE_boolean_t       boolean;
        SEE_number_t        number;
        struct SEE_string * string;
        struct SEE_object * object;
        <i>...</i>
    } u;
};</pre>

<p>
The first member, <code>_type</code>, is the discriminator,
and must be one of the enumerated values
<code>SEE_UNDEFINED</code>, <code>SEE_NULL</code>, 
<code>SEE_BOOLEAN</code>, <code>SEE_NUMBER</code>, <code>SEE_STRING</code> or
<code>SEE_OBJECT</code>.
You should access the <code>_type</code> member using the 
<code>SEE_VALUE_GET_TYPE()</code> macro.
</p>

<pre>enum { <i>...</i> } <dfn id="SEE_VALUE_GET_TYPE">SEE_VALUE_GET_TYPE</dfn>(struct SEE_value *value);</pre>

<p>
Depending on the type,
you can directly access the corresponding value of a 
<code>SEE_value</code>.
If the value variable is declared as:
</p>

<pre>struct SEE_value v;</pre>

<p>then the value that it holds is directly accessed through
its union member, <code>v.u</code>.
The following table shows when the union fields of <code>v.u</code> are valid:
</p>

<table>
<thead>
<tr>    <th><code>SEE_VALUE_GET_TYPE(&amp;v)</code></th>
        <th>Valid member</th>
        <th>Member's type</th>  </tr>
</thead>
<tbody>
<tr>    <td><code>SEE_UNDEFINED</code></td>
        <td><i>n/a</i></td>
        <td><i>n/a</i></td>                                     </tr>
<tr>    <td><code>SEE_NULL</code></td>
        <td><i>n/a</i></td>
        <td><i>n/a</i></td>                                     </tr>
<tr>    <td><code>SEE_BOOLEAN</code></td>
        <td><code>v.u.boolean</code></td>
        <td><code>SEE_boolean_t</code></td>             </tr>
<tr>    <td><code>SEE_NUMBER</code></td>
        <td><code>v.u.number</code></td>
        <td><code>SEE_number_t</code></td>              </tr>
<tr>    <td><code>SEE_STRING</code></td>
        <td><code>v.u.string</code></td>
        <td><code>struct SEE_string *</code></td>       </tr>
<tr>    <td><code>SEE_OBJECT</code></td>
        <td><code>v.u.object</code></td>
        <td><code>struct SEE_object *</code></td>       </tr>
</tbody></table>

<p>
Two other types (<code>SEE_COMPLETION</code> and <code>SEE_REFERENCE</code>)
are only used internally to SEE and are not documented here.
</p>

<p>
To convert/coerce values into values of a different types, use the 
utility functions describe in <a href="#conversion">&sect;5.1</a>.
</p>

<p>
To create new values in <code>struct SEE_value</code> structures, 
use the following initialisation macros. They first set the <code>_type</code> 
field and then copy the second parameter into the appropriate union field.
It is fine to use a local variable for a <code>struct SEE_value</code>,
because the garbage collector can see what is being used from the stack.
</p>

<pre>void <dfn id="SEE_SET_UNDEFINED">SEE_SET_UNDEFINED</dfn>(struct SEE_value *val);
void <dfn id="SEE_SET_NULL">SEE_SET_NULL</dfn>(struct SEE_value *val);
void <dfn id="SEE_SET_OBJECT">SEE_SET_OBJECT</dfn>(struct SEE_value *val, struct SEE_object *obj);
void <dfn id="SEE_SET_STRING">SEE_SET_STRING</dfn>(struct SEE_value *val, struct SEE_string *str);
void <dfn id="SEE_SET_NUMBER">SEE_SET_NUMBER</dfn>(struct SEE_value *val, SEE_number_t num);
void <dfn id="SEE_SET_BOOLEAN">SEE_SET_BOOLEAN</dfn>(struct SEE_value *val, SEE_boolean_t bool);</pre>

<p>
Most <code>SEE_value</code>s are passed about the SEE library functions using 
pointers. This is because the general contract is that the caller supplies
storage for the return value (usually named <code>ret</code>), while
other pointer arguments are treated as read-only.
Conventionally, the result value pointer is provided as the last argument 
to these functions and is named <code>res</code>.
</p>

<p class="note">
&#9888; Note:
The <code>SEE_VALUE_COPY()</code> macro breaks this convention
by instead following the better-known idiom of <code>memcpy()</code>, and
placing the destination first.
</p>

<p>
Avoid <em>storing</em> a <code>struct SEE_value</code> as a pointer.
Instead, extract and copy values into storage using the following macro:
</p>

<pre>void <dfn id="SEE_VALUE_COPY">SEE_VALUE_COPY</dfn>(struct SEE_value *dst, struct SEE_value *src);</pre>

<p>
A simple pitfall to avoid when passing values to SEE functions is to
use value storage as both a parameter to the function and as the return result
storage.
Do not do this.
It is possible that the function will initialise its return storage before it
accesses its parameters.
</p>

<h3 id="conversion">5.1 Value conversion</h3>

<p>
The ECMAScript language specification provides for conversion functions
that the host application developer may find useful. They convert arbitrary
values into values of a known type:
</p>

<ul>
<li><code>SEE_ToPrimitive()</code>
    - Returns a non-object value. It calls the
        object's <code>DefaultValue()</code> method
        (see <a href="#objimpl">&sect;6.3</a>)
<li><code>SEE_ToBoolean()</code>
    - Returns a value of type <code>SEE_BOOLEAN</code>
<li><code>SEE_ToNumber()</code>
    - Returns a value of type <code>SEE_NUMBER</code>
<li><code>SEE_ToInteger()</code>
    - Returns a value of type <code>SEE_NUMBER</code>
        that is also a finite integer
<li><code>SEE_ToString()</code>
    - Returns a value of type <code>SEE_STRING</code>
<li><code>SEE_ToObject()</code>
    - Returns a value of type <code>SEE_OBJECT</code>
        using the <code class="js">String</code>, 
        <code class="js">Number</code> and
        <code class="js">Boolean</code>
        constructors
</ul>

<pre>void <dfn id="SEE_ToPrimitive">SEE_ToPrimitive</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *hint,
                struct SEE_value *res);
void <dfn id="SEE_ToBoolean">SEE_ToBoolean</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *res);
void <dfn id="SEE_ToNumber">SEE_ToNumber</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *res);
void <dfn id="SEE_ToInteger">SEE_ToInteger</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *res);
void <dfn id="SEE_ToString">SEE_ToString</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *res);
void <dfn id="SEE_ToObject">SEE_ToObject</dfn>(struct SEE_interpreter *interp,
                struct SEE_value *val, struct SEE_value *res);</pre>

<h3 id="undef">5.2 Undefined, null, boolean and number values</h3>

<p>
The undefined and null types have exactly one implied value each, namely
<code class="js">undefined</code> and <code class="js">null</code>. 
</p>

<p class="note">
&#9888; Note:
<code class="js">null</code> is <em>not</em> an object type, and is
not related to C's <code>NULL</code> constant.
</p>

<p>
Boolean types (<code>SEE_boolean_t</code>) have values of either true (non-zero) or false (zero). 
</p>

<p>
Number values (<code>SEE_number_t</code>) are IEEE 754 signed floating 
point numbers, normally corresponding to the C compiler's built-in
<code>double</code> type.
</p>

<p>
The following macros may be used to find information about a number value.
(They assume that the <code>type</code> is <code>SEE_NUMBER</code>):
</p>

<ul>
<li><code>SEE_NUMBER_ISNAN()</code>  - return true if the value represents an error condition (not a number)
<li><code>SEE_NUMBER_ISPINF()</code> - return true if the value is +&infin;
<li><code>SEE_NUMBER_ISNINF()</code> - return true if the value is -&infin;
<li><code>SEE_NUMBER_ISINF()</code>  - return true if the value is &plusmn;&infin;
<li><code>SEE_NUMBER_ISFINITE()</code> - return true if the value is a finite number
</ul>

<pre>int <dfn id="SEE_NUMBER_ISNAN">SEE_NUMBER_ISNAN</dfn>(struct SEE_value *val);
int <dfn id="SEE_NUMBER_ISPINF">SEE_NUMBER_ISPINF</dfn>(struct SEE_value *val);
int <dfn id="SEE_NUMBER_ISNINF">SEE_NUMBER_ISNINF</dfn>(struct SEE_value *val);
int <dfn id="SEE_NUMBER_ISINF">SEE_NUMBER_ISINF</dfn>(struct SEE_value *val);
int <dfn id="SEE_NUMBER_ISFINITE">SEE_NUMBER_ISFINITE</dfn>(struct SEE_value *val);</pre>

<p>
SEE also provides constants <code>SEE_Infinity</code> and <code>SEE_NaN</code>
which may be stored in number values, but should not be used 
to compare number values with C's <code>==</code> operator.
Use the macros mentioned previously, instead.
</p>

<pre>const SEE_number_t <dfn id="SEE_Infinity">SEE_Infinity</dfn>;
const SEE_number_t <dfn id="SEE_NaN">SEE_NaN</dfn>;</pre>

<p>
Numbers (and other values) may be converted to integers using the functions
<code>SEE_ToInt32()</code>, <code>SEE_ToUint32()</code> or 
<code>SEE_ToUint16()</code>.
</p>

<pre>SEE_int32_t  <dfn id="SEE_ToInt32">SEE_ToInt32</dfn>(struct SEE_interpreter *interp, struct SEE_value *val);
SEE_uint32_t <dfn id="SEE_ToUint32">SEE_ToUint32</dfn>(struct SEE_interpreter *interp, struct SEE_value *val);
SEE_uint16_t <dfn id="SEE_ToUint16">SEE_ToUint16</dfn>(struct SEE_interpreter *interp, struct SEE_value *val);</pre>

<p>
SEE provides three data types
for integers:
</p>

<ul>
  <li> <code>SEE_uint16_t</code>        - 16 bit unsigned integer
  <li> <code>SEE_uint32_t</code>        - 32 bit unsigned integer
  <li> <code>SEE_int32_t</code>         - 32 bit signed integer
</ul>

<h3 id="string">5.3 String values</h3>

<p>
String values are pointers to <code>SEE_string</code> structures, 
that hold UTF-16 strings.
The structure is defined something like this:
</p>

<pre><dfn id="struct_SEE_string">struct SEE_string</dfn> {
        unsigned int     length;
        SEE_char_t      *data;
        <i>...</i>
};</pre>

<p>The useful members are:</p>

<ul>
<li><code>length</code>
- Length of string content
<li><code>data</code>
- Read-only storage for the string content (UTF-16 characters)
</ul>

<p>
Be aware that other strings may come to share the string's data, such
as by forming substrings. 
A string's content must not be modified after construction because of this
risk. However, the <code>length</code>
field of a string may be changed to a <strong>smaller</strong> value
at any time without concern.
</p>

<p>
The <code>SEE_char_t</code> type represents each Unicode character in the
string.  It is equivalent to a 16-bit unsigned integer.
</p>

<p>
To manipulate a string, first create a new string using one of the following:
</p>

<ul>    
  <li><code>SEE_string_new()</code> - create a new, empty string
  <li><code>SEE_string_dup()</code> - create a new string with duplicate content
  <li><code>SEE_string_sprintf()</code> - create a new string using 
        <code>printf</code>-like arguments (forced to 7-bit ASCII)
  <li><code>SEE_string_vsprintf()</code> - create a new string using
        <code>vprintf</code>-like arguments (forced to 7-bit ASCII)
</ul>

<p>
And then, before passing your new string to any other function, append 
characters to it using the following:
</p>

<ul>
  <li><code>SEE_string_addch()</code> - append a UTF-16 character
  <li><code>SEE_string_append()</code> - append contents of another string
  <li><code>SEE_string_append_ascii()</code> - convert 7bit ASCII to Unicode and append to another string
  <li><code>SEE_string_append_int()</code> - append a signed integer's
                                                representation in base 10
</ul>

<p>
Once a new string has been passed to any other SEE function, it should not
have its contents modified in any way.
Strings should not be shared
between different interpreters, unless internalised with 
<code>SEE_intern_global()</code> (see <a href="#staticstr">&sect;5.3.1</a>).
</p>

<p>
All strings in SEE use UTF-16 encoding, meaning that in some cases
you may need to be aware of Unicode 'surrogate' characters. If the host
application really needs UCS-4 strings (which are subtly different to UTF-16),
you will need to write your own converter function. Use the implementation of 
<code>SEE_input_string()</code> (<a href="#input">&sect;4.2</a>) as 
the basis for such a converter.
</p>

<p>
The functions 
<code>SEE_string_sprintf()</code> and <code>SEE_string_vsprintf()</code>
do not exactly have the same formats
as the standard <code>printf()</code> function, although they are
substantially similar. 
Follows is a table of understood formats:
</p>

<table>
<thead>
<tr><th>Format</th>
    <th>Type</th>
    <th>Comment</th></tr>
</thead>
<tbody>
<tr><td><code class="meta">%<i>[</i>+<i>][</i>-<i>][</i>0<i>][#]</i>d</code></td>
    <td><code>signed int</td>
    <td>decimal</td></tr>
<tr><td><code class="meta">%<i>[</i>+<i>][</i>-<i>][</i>0<i>][#]</i>u</code></td>
    <td><code>unsigned int<code></td>
    <td>decimal</td></tr>
<tr><td><code class="meta">%<i>[</i>+<i>][</i>-<i>][</i>0<i>][#]</i>x</code></td>
    <td><code>unsigned int</code></td>
    <td>hexadecimal (base 16)</td></tr>
<tr><td><code class="meta">%c</code></td>
    <td><code>char</code></td>
    <td>ASCII only</td></tr>
<tr><td><code class="meta">%C</code></td>
    <td><code>SEE_char_t</code></td></tr>
<tr><td><code class="meta">%<i>[</i>-<i>][#][</i>.<i>#]</i>s</code></td>
    <td><code>const char *</code></td>
    <td>ASCII only</td></tr>
<tr><td><code class="meta">%<i>[</i>-<i>][#][</i>.<i>#]</i>S</code></td>
    <td><code>struct SEE_string *</code></td></tr>
<tr><td><code class="meta">%<i>[</i>-<i>][#]</i>p</code></td>
    <td><code>void *</code></td></tr>
<tr><td><code class="meta">%%</code></td>
    <td></td>
    <td>single <code>%</code></td></tr>
</tbody>
</table>

<p>
Where a hash (<code class="meta"><i>#</i></code>) appears in the format column above, it means that either a positive
integer in base 10 may be supplied to indicate padding or precision, 
(eg <code>%4d</code>)
or an asterisk (<code>*</code>) can be used instead
to indicate that the next <code>int</code> argument provides the padding or precision value. 
This follows the behaviour of <code>printf()</code>.
</p>

<pre>struct SEE_string *<dfn id="SEE_string_new">SEE_string_new</dfn>(struct SEE_interpreter *interp,
                unsigned int space);
struct SEE_string *<dfn id="SEE_string_dup">SEE_string_dup</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *s);
struct SEE_string *<dfn id="SEE_string_sprintf">SEE_string_sprintf</dfn>(struct SEE_interpreter *interp,
                const char *fmt, ...);
struct SEE_string *<dfn id="SEE_string_vsprintf">SEE_string_vsprintf</dfn>(struct SEE_interpreter *interp,
                const char *fmt, va_list ap);</pre>

<pre>void <dfn id="SEE_string_addch">SEE_string_addch</dfn>(struct SEE_string *s, SEE_char_t ch);
void <dfn id="SEE_string_append">SEE_string_append</dfn>(struct SEE_string *s, const struct SEE_string *sffx);
void <dfn id="SEE_string_append_ascii">SEE_string_append</dfn>(struct SEE_string *s, const char *);
void <dfn id="SEE_string_append_int">SEE_string_append_int</dfn>(struct SEE_string *s, int i);</pre>

<p>
Other string functions provided are:
</p>

<ul>
 <li><code>SEE_string_substr()</code> 
        - create a read-only substring string
 <li><code>SEE_string_literal()</code>  
        - create a copy of the string, escaping chars and
          enclosing it in double quotes (<code>"</code>)
 <li><code>SEE_string_fputs()</code>    
        - write the string to the stdio file using UTF-8 encoding,
          returns <code>EOF</code> on error
 <li><code>SEE_string_toutf8()</code>    
        - copy the string into a C string buffer, using UTF-8 encoding,
          throwing an error if the buffer is too small
 <li><code>SEE_string_concat()</code>    
        - efficiently concatenate two strings, creating a new string
 <li><code>SEE_string_cmp()</code>      
        - compares two strings, like <code>strcmp()</code>
</ul>

<pre>struct SEE_string *<dfn id="SEE_string_substr">SEE_string_substr</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *s, int index, int length);
struct SEE_string *<dfn id="SEE_string_literal">SEE_string_literal</dfn>(struct SEE_interpreter *interp,
                const struct SEE_string *s);
int <dfn id="SEE_string_fputs">SEE_string_fputs</dfn>(const struct SEE_string *s, FILE *file);
void <dfn id="SEE_string_toutf8">SEE_string_toutf8</dfn>(struct SEE_interpreter *interp, 
                char *buffer, SEE_size_t buffer_size,
                const struct SEE_string *s);
struct SEE_string *<dfn id="SEE_string_concat">SEE_string_concat</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *s1, struct SEE_string *s2);
int <dfn id="SEE_string_cmp">SEE_string_cmp</dfn>(const struct SEE_string *s1,
                const struct SEE_string *s2);</pre>

<h4 id="intern">5.3.1 Internalised strings</h4>

<p>
If you find yourself comparing strings a lot, you may find it easier to
compare <em>internalised</em> strings. 
These are strings that are kept in a fast
hash table and may be compared equal using pointer equality. 
The <code>SEE_intern()</code> function returns an 'internalized' copy of the 
given string and is very fast on already-interned strings.
It is worth using in lieu of <code>SEE_string_cmp()</code> if the strings 
are likely to be intern'ed already. (For example, all property names in
the standard library are.)
</p>

<p>
The function <code>SEE_intern_ascii()</code> is a convenience function
that first converts the C string into a <code>SEE_string</code> before
intern'ing. The C string must be an ASCII string terminated by a null
character.
</p>

<pre>struct SEE_string *<dfn id="SEE_intern">SEE_intern</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *s);
struct SEE_string *<dfn id="SEE_intern_ascii">SEE_intern_ascii</dfn>(struct SEE_interpreter *interp,
                const char *s);</pre>

<h4 id="staticstr">5.3.2 Statically initialised strings</h4>

<p>
SEE supports statically initialised strings.
If you have a large number of strings to create and use (e.g. properties
and method names) over many interpreter instances, statically initialised
strings can save space, and improve performance.
</p>

<p>
A statically initialised string, '<code class="js">Hello, world</code>',
would look like this:
</p>

<pre><i>/* Example of a statically-initialised UTF-16 string */</i>
static SEE_char_t hello_world_chars[12] = {
    'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd'
};
static struct SEE_string hello_world = {
    12,                                                <i>/* length */</i>
    hello_world_chars                                  <i>/* data */</i>
};</pre>

<p>
The main problem with static strings is finding an elegant way
to initialise the strings' content. 
There is no simple way in ANSI C to have the compiler convert 
common ASCII strings into UTF-16 arrays.
The internal approach taken by SEE in supporting
all the standard ECMAScript object property names,
is to generate C program text from a file of
ASCII strings during the build process.
</p>

<p>
If an application wishes to internalise strings <em>across interpreters</em>,
it can add all its global strings into the global
intern table <strong>before creating any interpreters</strong>.
This is done by calling
<code>SEE_intern_global()</code> for each string.
Doing this can save a moderate amount of overhead, and can
improve performance if the intern'ed string needs to be used often.
</p>

<pre>struct SEE_string * <dfn id="SEE_intern_global">SEE_intern_global</dfn>(const char *str);</pre>

<p>
When creating global strings, the application can either use
the static initialisation technique described above, or create
interpreter-less strings by passing a <code>NULL</code> interpreter pointer
to the various string creation functions (<a href="#string">&sect;5.3</a>).
Such strings should be placed into the global intern table, immediately.
</p>

<h2 id="object">6 Objects</h2>

<p>
ECMAScript uses a prototype-inheritance object model with simple named
properties. More information on the object model can be found in the 
<a href="#ref-ecma">ECMA-262 standard</a>, and in other JavaScript references.
</p>

<p>
This section describes how in-memory objects can be accessed
and manipualated (the 'client interface'),
and also how host applications can expose their own application objects
and methods (the 'implementation interface').
</p>

<p>
Object instances are implemented as in-memory structures, with an 
<code>objectclass</code> pointer to a table of operational methods.
Object references are held inside values with a type field
of <code>SEE_OBJECT</code> (see <a href="#value">&sect;5</a>).
</p>

<p>
If you want to create a plain object quickly from C, 
the convenience function
<code>SEE_Object_new()</code>
is the same as evaluating
<code class="js">new Object()</code>.

<pre>struct SEE_object *<dfn id="SEE_Object_new">SEE_Object_new</dfn>(struct SEE_interpreter *interp);</pre>

<h3 id="objclient">6.1 Object values, and the object client interface</h3>

<p>
All object values are pointers to object instances.
The pointers are of type <code>struct SEE_object *</code>.
No object pointer in a <code>SEE_value</code> should ever point to
<code>NULL</code>.
I find working with <code>struct SEE_object *</code> pointer 
types directly, instead of using <code>struct SEE_value</code> to be
convenient, when I know that I am dealing with objects.
</p>

<p>
To use an existing object instance, you should interact with it using 
its <q>internal methods</q>. 
These should be invoked by using the following macros:
</p>

<ul>
<li><code>SEE_OBJECT_GET()</code>
        - retrieve a named property or return <code class="js">undefined</code>
          ('<code class="js">o.prop</code>');
          also known as the <code class="js">[[Get]]</code> internal method
<li><code>SEE_OBJECT_PUT()</code>
        - create/update a named property
          ('<code class="js">o.prop = val</code>');
          also known as the <code class="js">[[Put]]</code> internal method
<li><code>SEE_OBJECT_CANPUT()</code>
        - returns true if the property can be changed;
          also known as the <code class="js">[[CanPut]]</code> internal method;
          assumes <code>prop</code> is an internalised string
<li><code>SEE_OBJECT_HASPROPERTY()</code>
        - tests for existence of a property
          ('<code class="js">"prop" in o</code>');
          also known as the <code class="js">[[HasProperty]]</code> 
          internal method;
          assumes <code>prop</code> is an internalised string
<li><code>SEE_OBJECT_DELETE()</code>
        - delete a property; returns true on success 
          ('<code class="js">delete o.prop</code>');
          also known as the <code class="js">[[Delete]]</code> internal method
<li><code>SEE_OBJECT_DEFAULTVALUE()</code>
        - returns the string or number value associated with the object;
          also known as the <code class="js">[[DefaultValue]]</code> 
          internal method
<li><code>SEE_OBJECT_CONSTRUCT()</code>
          <a href="#objcheck" class="footnote">&dagger;</a>
        - call object as a constructor
          ('<code class="js">new o(<i>...</i>)</code>');
          also known as the <code class="js">[[Construct]]</code> 
          internal method
<li><code>SEE_OBJECT_CALL()</code>
          <a href="#objcheck" class="footnote">&dagger;</a>
        - call object as a function ('<code class="js">o(<i>...</i>)</code>');
          also known as the <code class="js">[[Call]]</code> 
          internal method
<li><code>SEE_OBJECT_HASINSTANCE()</code>
          <a href="#objcheck" class="footnote">&dagger;</a>
        - return true if the objects are related
          ('<code class="js">x instanceof o</code>');
          also known as the <code class="js">[[HasInstance]]</code> 
          internal method
<li><code>SEE_OBJECT_ENUMERATOR()</code>
          <a href="#objcheck" class="footnote">&dagger;</a>
        - create a property enumerator
          ('<code class="js">for (i in o) <i>...</i></code>')
<li><code>SEE_OBJECT_GET_SEC_DOMAIN()</code>
          <a href="#objcheck" class="footnote">&dagger;</a>
        - returns the security domain associated with callable objects
          (see <a href="#security">&sect;9</a>)
</ul>

<pre>void <dfn id="SEE_OBJECT_GET">SEE_OBJECT_GET</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_string *prop,
                struct SEE_value *res);
void <dfn id="SEE_OBJECT_PUT">SEE_OBJECT_PUT</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_string *prop,
                struct SEE_value *res, int flags);
int <dfn id="SEE_OBJECT_CANPUT">SEE_OBJECT_CANPUT</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_string *prop);
int <dfn id="SEE_OBJECT_HASPROPERTY">SEE_OBJECT_HASPROPERTY</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_string *prop);
int <dfn id="SEE_OBJECT_DELETE">SEE_OBJECT_DELETE</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_string *prop);
void <dfn id="SEE_OBJECT_DEFAULTVALUE">SEE_OBJECT_DEFAULTVALUE</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_value *hint,
                struct SEE_value *res);
void <dfn id="SEE_OBJECT_CONSTRUCT">SEE_OBJECT_CONSTRUCT</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_object *thisobj,
                int argc, struct SEE_value **argv,
                struct SEE_value *res);
void <dfn id="SEE_OBJECT_CALL">SEE_OBJECT_CALL</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_object *thisobj,
                int argc, struct SEE_value **argv,
                struct SEE_value *res);
int <dfn id="SEE_OBJECT_HASINSTANCE">SEE_OBJECT_HASINSTANCE</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj, struct SEE_value *instance);
struct SEE_enum *<dfn id="SEE_OBJECT_ENUMERATOR">SEE_OBJECT_ENUMERATOR</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj);
void *<dfn id="SEE_OBJECT_GET_SEC_DOMAIN">SEE_OBJECT_GET_SEC_DOMAIN</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *obj);</pre>

<p id="objcheck">
<span class="footnote">&dagger;</span>
Five of the macros above (<code>CONSTRUCT</code>, 
<code>CALL</code>, <code>HASINSTANCE</code>,
<code>ENUMERATOR</code> and <code>GET_SEC_DOMAIN</code>) 
call optional internal methods, and
<strong>do not check</strong> if the object class has not provided them.
This means the macros may try to call through a <code>NULL</code> function 
pointer, which will cause an error.
You can determine if the object's class provides 
the optional methods by using the following macros before you use one of the
four marked above.
These check macros returns true if the method they check for is valid
(i.e. they check the function pointer in the object class is
non-<code>NULL</code>):
</p>

<ul>
<li><code>SEE_OBJECT_HAS_CALL()</code>
         - object can be called with <code>SEE_OBJECT_CALL()</code>
<li><code>SEE_OBJECT_HAS_CONSTRUCT()</code>
         - object can be called with <code>SEE_OBJECT_CONSTRUCT()</code>
<li><code>SEE_OBJECT_HAS_HASINSTANCE()</code>
         - object can be called with <code>SEE_OBJECT_HASINSTANCE()</code>
<li><code>SEE_OBJECT_HAS_ENUMERATOR()</code>
         - object can be called with <code>SEE_OBJECT_ENUMERATOR()</code>
<li><code>SEE_OBJECT_HAS_GET_SEC_DOMAIN()</code>
         - object can be called with <code>SEE_OBJECT_GET_SEC_DOMAIN()</code>
</ul>

<pre>int <dfn id="SEE_OBJECT_HAS_CALL">SEE_OBJECT_HAS_CALL</dfn>(struct SEE_object *obj);
int <dfn id="SEE_OBJECT_HAS_CONSTRUCT">SEE_OBJECT_HAS_CONSTRUCT</dfn>(struct SEE_object *obj);
int <dfn id="SEE_OBJECT_HAS_HASINSTANCE">SEE_OBJECT_HAS_HASINSTANCE</dfn>(struct SEE_object *obj);
int <dfn id="SEE_OBJECT_HAS_ENUMERATOR">SEE_OBJECT_HAS_ENUMERATOR</dfn>(struct SEE_object *obj);
int <dfn id="SEE_OBJECT_HAS_GET_SEC_DOMAIN">SEE_OBJECT_HAS_GET_SEC_DOMAIN</dfn>(struct SEE_object *obj);</pre>

<p>
When storing properties in an object with <code>SEE_OBJECT_PUT()</code>, 
a <code>flags</code> parameter is required. 
In normal operation, this flag should be supplied as zero, but when populating
an object with its properties for the first time, the following bit
flags can be used:
</p>

<table>
<thead>
<tr><th>Flag</th>
    <th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>SEE_ATTR_READONLY</code></td>
    <td>Future assignments (puts) on this property will fail</td></tr>
<tr><td><code>SEE_ATTR_DONTENUM</code></td>
    <td>Enumerators will not list this property
        and will hide inherited prototype properties of
        the same name until this property is <code class="js">delete</code>d.
        (see <a href="#enum">&sect;6.2</a>)</td></tr>
<tr><td><code>SEE_ATTR_DONTDELETE</code></td>
    <td>Future <code class="js">delete</code>s on this property will 
        fail</td></tr>
</tbody>
</table>

<h3 id="enum">6.2 Property enumerators</h3>

<p>
A property enumerator is a mechanism for discovering the properties that
an object contains. The language exercises this with its
<code class="js">for (var v in <i>...</i>)</code> construct.
The results of the enumeration need not be sorted, nor even
to be the same order each time. 
</p>

<p>
Calling <code>SEE_OBJECT_ENUMERATOR()</code> returns a 
newly created <i>enumerator</i> which is a pointer to a
<code>struct SEE_enum</code>.
Once obtained, the following macros can be used to access the enumerator:
</p>

<ul>
 <li><code>SEE_ENUM_NEXT()</code>
        - return a pointer to a property name string, or <code>NULL</code>
          when the properties have been exhausted.
</ul>

<pre>struct SEE_string *<dfn id="SEE_ENUM_NEXT">SEE_ENUM_NEXT</dfn>(struct SEE_interpreter *interp,
                struct SEE_enum *e, int *flags_return);</pre>

<p>
Enumerators can assume that the underlying object does not change during
enumeration. 
A suggested strategy for a caller that does need to remove or add an object's
properties while enumerating them
is to first create a private list of its property names, ensuring that it
has exhausted the enumerator before attempting to modify the object.
</p>

<pre><i>/* An example of enumerating properties on an object from C */</i>
void
print_properties(struct SEE_interpreter *interp, struct SEE_object *obj)
{
        struct SEE_enum *enumerator;
        struct SEE_string *prop;

        <i>/* Ignore objects that don't provide an enumerator */</i>
        if (!<b>SEE_OBJECT_HAS_ENUMERATOR</b>(obj))
                return;

        enumerator = <b>SEE_OBJECT_ENUMERATOR</b>(interp, obj);
        while ((prop = <b>SEE_ENUM_NEXT</b>(interp, enumerator, NULL)) != NULL) {
                SEE_PrintString(interp, prop, stdout);
                printf("\n");
        }
}</pre>


<h3 id="objimpl">6.3 The object implementation interface</h3>

<p>
When a host application wishes to expose its own 'host objects' to 
ECMAScript programs, it must use the object implementation API
described in this section.
</p>

<p>
All SEE objects are in-memory structures starting with a 
<code>struct SEE_object</code>:
</p>

<pre><dfn id="struct_SEE_object">struct SEE_object</dfn> {
        struct SEE_objectclass *objectclass;
        struct SEE_object *     Prototype;
};</pre>

<p>
Normally, this structure is part of a larger structure that maintains the
object's private state. For example, native <code class="js">Number</code>
objects could be implemented with the following:
</p>

<pre>struct number_object {             <i>/* example implementation of Number */</i>
        struct SEE_object object;
        SEE_number_t      number;
};</pre>

<p>
Keeping the <code>object</code> part at the top of the 
<code>number_object</code> structure means that pointers of type
<code>struct number_object *</code> can be cast to and from pointers of type
<code>struct SEE_object *</code>. This is a general idiom: begin all
host object structures with a field member of type
<code>struct SEE_object</code> named <code>object</code>.
</p>

<p>
Although the ECMAScript language does not use classes <i>per se</i>,
SEE's internal object implementation does use a class 'abstraction'
to speed up execution and make implementation re-use easier.
Each object has a field, <code>object.objectclass</code>, that must
be initialised to point to a <code>struct SEE_objectclass</code> that 
provides the object's behaviour. The class structure looks like this:
</p>

<pre><dfn id="struct_SEE_objectclass">struct SEE_objectclass</dfn> {
        const char *            Class;          <i>/* mandatory */</i>
        SEE_get_fn_t            Get;            <i>/* mandatory */</i>
        SEE_put_fn_t            Put;            <i>/* mandatory */</i>
        SEE_boolean_fn_t        CanPut;         <i>/* mandatory */</i>
        SEE_boolean_fn_t        HasProperty;    <i>/* mandatory */</i>
        SEE_boolean_fn_t        Delete;         <i>/* mandatory */</i>
        SEE_default_fn_t        DefaultValue;   <i>/* mandatory */</i>
        SEE_enumerator_fn_t     enumerator;     <i>/* optional */</i>
        SEE_call_fn_t           Construct;      <i>/* optional */</i>
        SEE_call_fn_t           Call;           <i>/* optional */</i>
        SEE_hasinstance_fn_t    HasInstance;    <i>/* optional */</i>
        SEE_get_sec_domain_fn_t get_sec_domain; <i>/* optional */</i>
};</pre>

<p>
The application generally provides this structure in static storage, as
most of its members are function pointers or strings known at compile time.
A member marked <i>optional</i> should be set to <code>NULL</code> if it is
meaningless.
</p>

<p>
The object methods marked <i>mandatory</i>
(<code>Get</code>, <code>Put</code>, etc.)
are never <code>NULL</code>, and should provide the precise behaviours 
that SEE expects on native objects.
These behaviours are fully described in the 
ECMA-262 standard, and are summarised in the following table:
</p>

<table>
<thead>
<tr><th>Method</th>
    <th>Behaviour</th></tr>
</thead>
<tbody>
<tr><td><code>Get</code></td>
    <td>retrieve a named property (or return <code class="js">undefined</code>)</td></tr>
<tr><td><code>Put</code></td>
    <td>create/update a named property</td></tr>
<tr><td><code>Delete</code></td>
    <td>delete a property or return 0</td></tr>
<tr><td><code>HasProperty</code></td>
    <td>returns 0 if the property doesn't exist</td></tr>
<tr><td><code>CanPut</code></td>
    <td>returns 0 if the property cannot be changed</td></tr>
<tr><td><code>DefaultValue</code></td>
    <td>turns the object into a string or number value</td></tr>
<tr><td><code>enumerator</code></td>
    <td>allow enumeration of the properties (see above)</td></tr>
<tr><td><code>Construct</code></td>
    <td>constructs a new object; as per the
        <code class="js">new</code> keyword</td></tr>
<tr><td><code>Call</code></td>
    <td>the object has been called as a function</td></tr>
<tr><td><code>HasInstance</code></td>
    <td>returns 0 if the objects are unrelated</td></tr>
<tr><td><code>get_sec_domain</code></td>
    <td>returns the security domain associated with functions</td></tr>
</tbody>
</table>

<p>
It is up to the host application to provide storage for the properties, and
so forth. The simplest strategy is to ignore property calls to
<code>Put</code> and <code>Get</code> that are meaningless.
To this end, if the host object does not want to expend effort
supporting some of the mandatory operations, it can use the 
corresponding 'do-nothing' function(s) from this list:
</p>

<ul>
  <li><code>SEE_no_get()</code>
  <li><code>SEE_no_put()</code>
  <li><code>SEE_no_canput()</code>
  <li><code>SEE_no_hasproperty()</code>
  <li><code>SEE_no_delete()</code>
  <li><code>SEE_no_defaultvalue()</code>
  <li><code>SEE_no_enumerator()</code>
</ul>

<p>
The <code>Prototype</code> field of an object instance
can either be set to:
</p>

<ul><li>the interpreter's <code>Object_prototype</code>, 
<li>to <code>NULL</code> (meaning no prototype), or 
<li>to some other object. (Be careful to avoid a prototype cycle!)</ul>
If you choose to use <code>NULL</code>, it is recommended you provide a 
<code class="js">toString()</code> method (to help with debugging).

<p>
Once the host application has constructed its own objects that
conform to the API, they can be inserted into the 'Global object'
as object-valued properties.
</p>

<p>
The 'Global object' is an unnamed, top-level object whose sole purpose
is to 'hold' all the built-in objects, such as <code class="js">Object</code>,
<code class="js">Function</code>, <code class="js">Math</code>,
etc., as well as all user-declared global variables. The host
application can access it through the <code>Global</code> member of the
<code>SEE_interpreter</code> structure.
</p>


<h3 id="native">6.4 Native objects</h3>

<p>
SEE provides support for a special kind of object class called <em>native 
objects</em>. Native objects maintain a hash table of properties, and 
implement the mandatory methods (plus <code>enumerator</code>), and 
correctly observe the <code>Prototype</code> field.
</p>

<pre><dfn id="struct_SEE_native">struct SEE_native</dfn> {
        struct SEE_object       object;
        struct SEE_property *   properties[SEE_NATIVE_HASHLEN];
};</pre>

<p>
An application can create host objects based on native objects.
First, place a <code>struct SEE_native</code> at the beginning of a
structure:
</p>

<pre>struct some_host_object {
        struct SEE_native       native;
        int                     host_specific_info;
};</pre>

<p>
Then, use the following objects methods, either directly in the 
<code>SEE_objectclass</code> structure, or by calling them indirectly 
from method implementations:
</p>

<ul>
  <li><code>SEE_native_get()</code>
  <li><code>SEE_native_put()</code>
  <li><code>SEE_native_canput()</code>
  <li><code>SEE_native_hasproperty()</code>
  <li><code>SEE_native_delete()</code>
  <li><code>SEE_native_defaultvalue()</code>
  <li><code>SEE_native_enumerator()</code>
</ul>

<p>
It is very important that you initialize the <code>native</code>
field when constructing your host object.
Do this using the <code>SEE_native_init()</code> function.
</p>

<pre>void <dfn id="SEE_native_init">SEE_native_init</dfn>(struct SEE_native *obj, struct SEE_interpreter *i,
                const struct SEE_objectclass *obj_class, 
                struct SEE_object *prototype);</pre>

<h3 id="cfunction">6.5 C function objects</h3>

<p>
The host application will likely want a particular bit of C code to be able
to be called from the runtime environment.
To do this simply requires construction of an object whose 
<code>Prototype</code> field points to
<code class="js">Function.prototype</code>,
and whose <code>objectclass</code>'s <code>Call</code> method points to a 
C function that contains the desired code.
</p>

<p>
The convenience function <code>SEE_cfunction_make()</code> performs this
construction.
It takes a pointer to the C 
function, and an integer indicating the expected number of arguments. 
(The integer becomes the function object's
<code class="js">length</code> property, which is advisory only.)
</p>

<pre>struct SEE_object *<dfn id="SEE_cfunction_make">SEE_cfunction_make</dfn>(struct SEE_interpreter *interp,
                SEE_call_fn_t func, struct SEE_string *name, int argc);</pre>

<p class="note">
&#9888; Note:
Objects returned by <code>SEE_cfunction_make()</code> should really only 
be used in the interpreter context in which they were created, but the 
current version of SEE does not check for this. (Because cfunction objects 
are essentially read-only after construction, and if memory allocation
operates independently of the interpreters, sharing cfunction objects 
across interpreters will be OK, but it is not recommended for future
portability.)
</p>

<p>
The C function must conform to the <code>SEE_call_fn_t</code> signature.
This is demonstrated below, with <code>math_sqrt()</code>, which is
the actual code behind the <code class="js">Math.sqrt</code> object:
</p>

<pre><i>/* Implementation of Math.sqrt() method */</i>
static void
math_sqrt(interp, self, thisobj, argc, argv, res)
        struct SEE_interpreter *interp;
        struct SEE_object *self, *thisobj;
        int argc;
        struct SEE_value **argv, *res;
{
        struct SEE_value v;

        if (argc == 0)
                SEE_SET_UNDEFINED(res);
        else {
                SEE_ToNumber(interp, argv[0], &amp;v);
                SEE_SET_NUMBER(res, sqrt(v.u.number));
        }
}</pre>

<p>
<!-- from <code>SEE_OBJECT_CALL</code> -->
The arguments to this function
are described in the following table:
</p>

<table>
<thead>
<tr><th>Argument</th>
    <th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>interp</code></td>
    <td>the current interpreter context</td></tr>
<tr><td><code>self</code></td>
    <td>a pointer to the object called 
        (<code class="js">Math.sqrt</code> here)</td></tr>
<tr><td><code>thisobj</code></td>
    <td>the <code class="js">this</code> object 
        (the <code class="js">Math</code> object here)</td></tr>
<tr><td><code>argc</code></td>
    <td>number of arguments</td></tr>
<tr><td><code>argv</code></td>
    <td>array of value pointers, of length <code>argc</code></td></tr>
<tr><td><code>res</code></td>
    <td>uninitialised value location in which to store the result</td></tr>
</tbody>
</table>

<p>
A common convention in all ECMAScript functions is that unspecified
arguments should be treated as <code class="js">undefined</code>, and
extraneous arguments should just be ignored.
If the function uses <code>thisobj</code>, 
it should check any assumptions made about it, especially if it is expected
to be a host object.
This is because method functions can easily be attached to
other objects by user code.
</p>

<p>
When writing cfunctions, you can use the <code>SEE_parse_args()</code>
convenience function to make argument processing easier.
This function takes a format string and converts arguments according to
the table below.
It can throw a <code class="js">TypeError</code> exception if a
conversion error occurs.

<pre>void <dfn id="SEE_parse_args">SEE_parse_args</dfn>(struct SEE_interpreter *interp,
        int argc, struct SEE_value **argv, const char *fmt, ...);</pre>

<table>
<thead>
<tr><th>Format</th>
    <th>Parameter type</th>
    <th>Conversion applied</th>
    <th>Result when <code class="js">undefined</code></th></tr>
</thead>
<tbody>
<tr><td><code>a</code></td>
    <td><code>char **</code>
    <td><code><a href="#SEE_ToString">SEE_ToString</a>()</code>,
        then into an ASCII C string</td>
    <td><code>"undefined"</code></td>
<tr><td><code>A</code></td>
    <td><code>char **</code>
    <td><code>NULL</code> if <code class="js">undefined</code>,
        otherwise the same as format '<code>a</code>'</td>
    <td><code>NULL</code></td>
<tr><td><code>b</code></td>
    <td><code>int *</code>
    <td><code><a href="#SEE_ToBoolean">SEE_ToBoolean</a>()</code></td>
    <td><code>0</code></td>
<tr><td><code>h</code></td>
    <td><code>SEE_uint16_t *</code>
    <td><code><a href="#SEE_ToUint16">SEE_ToUint16</a>()</code></td>
    <td><code>0</code></td>
<tr><td><code>i</code></td>
    <td><code>SEE_int32_t *</code>
    <td><code><a href="#SEE_ToInt32">SEE_ToInt32</a>()</code></td>
    <td><code>0</code></td>
<tr><td><code>n</code></td>
    <td><code>SEE_number_t *</code>
    <td><code><a href="#SEE_ToNumber">SEE_ToNumber</a>()</code></td>
    <td><code>SEE_NaN</code></td>
<tr><td><code>o</code></td>
    <td><code>struct SEE_object **</code>
    <td><code><a href="#SEE_ToObject">SEE_ToObject</a>()</code></td>
    <td><code class="js">TypeError</code></td>
<tr><td><code>O</code></td>
    <td><code>struct SEE_object **</code>
    <td><code>NULL</code> if <code class="js">undefined</code>
    	or <code class="js">null</code>,
        otherwise the same as format '<code>o</code>'</td>
    <td><code>NULL</code></td>
<tr><td><code>p</code></td>
    <td><code>struct SEE_value *</code>
    <td><code><a href="#SEE_ToPrimitive">SEE_ToPrimitive</a>()</code></td>
    <td><code class="js">undefined</code></td>
<tr><td><code>s</code></td>
    <td><code>struct SEE_string **</code>
    <td><code><a href="#SEE_ToString">SEE_ToString</a>()</code></td>
    <td><code class="js">"undefined"</code></td>
<tr><td><code>u</code></td>
    <td><code>SEE_uint32_t *</code>
    <td><code><a href="#SEE_ToUint32">SEE_ToUint32</a>()</code></td>
    <td><code>0</code></td>
<tr><td><code>v</code></td>
    <td><code>struct SEE_value *</code>
    <td>the argument is copied without conversion</td>
    <td><code class="js">undefined</code></td>
<tr><td><code>x</code></td>
    <td></td>
    <td>the argument is ignored</td>
    <td></td>
<tr><td><code>z</code></td>
    <td><code>char **</code>
    <td><code><a href="#SEE_ToString">SEE_ToString</a>()</code>,
        then into a UTF8 C string</td>
    <td><code>"undefined"</code></td>
<tr><td><code>Z</code></td>
    <td><code>char **</code>
    <td><code>NULL</code> if <code class="js">undefined</code>,
        otherwise the same as format '<code>z</code>'</td>
    <td><code>NULL</code></td>
<tr><td><code>|</code></td>
    <td></td>
    <td>optional argument marker
<tr><td><code>.</code></td>
    <td></td>
    <td>throws a <code class="js">TypeError</code> on further
        arguments</td>
<tr><td>space</td>
    <td></td>
    <td>space character is ignored</td>
</tbody>
</table>

<p>The optional argument marker ('<code>|</code>') disables
storing a result when the argument is 
<code class="js">undefined</code> or not provided by the caller.
This allows storage to be initialised to default values.

<p>The '<code>a</code>' and '<code>A</code>' formats will
throw a <code class="js">TypeError</code> if the string contains
non-ASCII characters. 

<p>An example of using <code>SEE_parse_args()</code>:

<pre><i>/* Possible implementation of Math.sqrt() method */</i>
static void
math_sqrt_possible(interp, self, thisobj, argc, argv, res)
        struct SEE_interpreter *interp;
        struct SEE_object *self, *thisobj;
        int argc;
        struct SEE_value **argv, *res;
{
        SEE_number_t n;

	<b>SEE_parse_args</b>(interp, argc, argv, "n", &amp;n);
	SEE_SET_NUMBER(res, sqrt(n));
}</pre>


<h3 id="function">6.6 User function objects</h3>

<p>
Occasionally, a host application will wish to take some user text and 
create a callable function object from it. An example of this problem is 
in attaching the JavaScript code from HTML attributes onto form 
elements of a web page.
One way to achieve this is to invoke the <code class="js">Function</code> 
constructor object with the
<code>SEE_OBJECT_CONSTRUCT()</code> macro, passing it the formal arguments
text and body text as arguments.
(See <a href="#ref-ecma">the ECMAScript standard</a> for details on the
<code class="js">Function</code> constructor.)
</p>

<p>
Another way, that is more convenient if the user text is available as 
an input stream, is to use the <code>SEE_Function_new()</code> function:
</p>

<pre>struct SEE_object *<dfn id="SEE_Function_new">SEE_Function_new</dfn>(struct SEE_interpreter *interp, 
                struct SEE_string *name, struct SEE_input *param_input, 
                struct SEE_input *body_input);</pre>

<p>
where any of the the <code>name</code>, <code>param_input</code> and
<code>body_input</code> parameters may be <code>NULL</code>
(indicating to use the empty string).
</p>

<p>
The returned function object may be called with the 
<code>SEE_OBJECT_CALL()</code> macro.
</p>


<h3 id="error">6.7 Errors and Error objects</h3>

<p>
Host applications sometimes need to convey errors to ECMAScript programs.
Errors in ECMAScript are typically indicated by throwing an exception
with an object value.  The thrown objects conventionally have 
<code class="js">Error.prototype</code> somewhere in their prototype chain, 
and provide a <code class="js">message</code> and <code class="js">name</code> 
property which the <code class="js">Error.prototype</code> reads to generate
a human-readable error message.
</p>

<p>
Host applications can conveniently construct and throw error exceptions using 
the following macros:
</p>

<pre>void <dfn id="SEE_error_throw">SEE_error_throw</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *error_constructor,
                const char *fmt, ...);
void <dfn id="SEE_error_throw_string">SEE_error_throw_string</dfn>(struct SEE_interpreter *interp, 
                struct SEE_object *error_constructor,
                struct SEE_string *string);
void <dfn id="SEE_error_throw_sys">SEE_error_throw_sys</dfn>(struct SEE_interpreter *interp,
                struct SEE_object *error_constructor,
                const char *fmt, ...);</pre>

<p>
These convenience macros construct a new error object, and throw it as an 
exception using <code>SEE_THROW()</code>.
The object thrown is given a <code class="js">message</code>
string property that reflects the rest of the arguments provided 
to the called macro.
The <code>SEE_error_throw_sys()</code> macro works like
<code>SEE_error_throw()</code> but appends a textual 
description of <code>errno</code> using <code>strerror()</code>.
</p>

<p>
The <code>error_constructor</code> argument should be one of the error 
constructor objects found in the <code>SEE_interpreter</code> structure:
</p>

<table>
<thead>
<tr><th>Member</th>
    <th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>Error</code></td>
    <td>runtime error</td></tr>
<tr><td><code>EvalError</code></td>
    <td>error in <code class="js">eval()</code></td></tr>
<tr><td><code>RangeError</code></td>
    <td>numeric argument has exceeded allowable range</td></tr>
<tr><td><code>ReferenceError</code></td>
    <td>invalid reference was detected</td></tr>
<tr><td><code>SyntaxError</code></td>
    <td>parsing error</td></tr>
<tr><td><code>TypeError</code></td>
    <td>actual type of an operand different to that expected</td></tr>
<tr><td><code>URIError</code></td>
    <td>error in a global URI handling function</td></tr>
</tbody>
</table>

<p>
A simple example:
</p>

<pre>if (something_is_wrong)
        SEE_error_throw(interp, interp-&gt;Error, "something is wrong!");</pre>

<p>
Although <code>Error</code> is usually sufficient for most errors,
host applications can create their own error constructor object with the
<code>SEE_Error_make()</code> convenience function. Only one constructor
of the same name should be created per interpreter.
</p>

<pre>struct SEE_object *<dfn id="SEE_Error_make">SEE_Error_make</dfn>(struct SEE_interpreter *interp,
                struct SEE_string *name);</pre>

<h2 id="modules">7 Modules</h2>

<p>
SEE provides a module abstraction for host implementations that want
a structured approach to adding their objects into a SEE interpreter.
</p>

<p>
A <code>struct SEE_module</code> is a collection of functions
that are automatically called by SEE at various stages of each intepreter 
initialisation. The module may initialise and insert its own objects into 
each interpreter before user scripts can be run.
</p>

<pre><dfn id="struct_SEE_module">struct SEE_module</dfn> {
        SEE_uint32_t      magic;
        const char       *name;
        const char       *version;
        unsigned int      index;        <i>/* Set by SEE_module_add() */</i>
        int             (*mod_init)(void);
        void            (*alloc)(struct SEE_interpreter *);
        void            (*init)(struct SEE_interpreter *);
};</pre>

<p>
The <code>magic</code> field must be initialised to the constant value
<code>SEE_MODULE_MAGIC</code>.
The <code>name</code> field is currently unused, but should consist
of a short, unique identifier corresponding to the name of the module.
The <code>version</code> field is similarly optional, but should contain
at least a version number besides other descriptively identifying text.
The <code>index</code> field is set by the <code>SEE_module_add()</code>
function as the module is added to SEE. 
Each added module is given a unique index. Do not change the index.
</p>

<p>
The <code>mod_init</code> function pointer is called immediately the module
is loaded (by <code>SEE_module_add()</code>). 
This is an opportunity for
a module to obtain pointers to globally interned strings.
(See <code>SEE_intern_global()</code> in <a href="#staticstr">&sect;5.3.2</a>.)
The <code>mod_init</code> function is expected to return zero to indicate
a successful initialisation.
This pointer may be set to <code>NULL</code> if unneeded.
</p>

<p>
The <code>alloc</code> function is called after built-in objects have
been allocated but before any other modules or built-in objects have been
initialised. It is dangerous to make use of the interpreter at this stage.
The main use of the <code>alloc</code> function pointer is to allow 
circular dependencies between modules. 
For most modules, the <code>alloc</code> pointer can be left as 
<code>NULL</code>.
</p>

<p>
The <code>init</code> function is called after all built-in objects and
modules have been allocated, and after all built-in objects have been
initialised.
It is safe to make use of the interpreter built-ins at this stage, but
not to make use of other modules.
For most modules, the <code>init</code> function is the place to
insert newly-created host objects into a pristine 
<code>interp-&gt;Global</code>.
</p>

<p>
A pointer to your module structure must be passed to 
<code>SEE_module_add()</code> before any interpreters are created.
It is not possible to dynamically add modules once interpreters have
been created because of the way the global intern table is managed.
(If your module does not modify the global intern table, and your system
is single-threaded, then you may be able to add the module dynamically.)
</p>

<p>Finally, per-interpreter private storage for each module is 
provided through the <code>SEE_MODULE_PRIVATE()</code> macro.
This macro evaluates to a <code>void *</code> lvalue that may be 
assigned dynamic storage during <code>alloc</code>.
</p>

<pre>const SEE_uint32_t <dfn id="SEE_MODULE_MAGIC">SEE_MODULE_MAGIC</dfn>;
int <dfn id="SEE_module_add">SEE_module_add</dfn>(struct SEE_module *module);
void *<dfn id="SEE_MODULE_PRIVATE">SEE_MODULE_PRIVATE</dfn>(struct SEE_interpreter *, struct SEE_module *);</pre>

<p>
The <code>SEE_module_add()</code> function adds a module to the
global list of modules initialised whenever a new interpreter
is constructed. This function returns zero if the module was added
successfully. It returns <code>-1</code> if an internal error occurred.
Otherwise it returns the same non-zero value that the module's 
<code>mod_init</code> function hook returned.
Once added, a module cannot be removed.
</p>

<p>
The interested reader is referred to the <i>mod_File.c</i> module example
under the <i>shell</i> directory of the SEE source code.
</p>

<h2 id="compat">8 Compatibility features</h2>
<h3 id="compatjs">8.1 Compatibility with other JavaScript implementations</h3>

<p>
SEE provides backward-compatibility with earlier versions of JavaScript
and JScript.
These features ought never be used, since JavaScript program authors should be
mindful of standards.
Nevertheless, this section documents the compatibility modes that SEE supplies.
</p>

<p>
The behaviour of the SEE library is modified on a per-interpreter basis,
by passing special flags to a variant of the interpreter's initialisation
routine, <code>SEE_interpreter_init_compat()</code>. This function otherwise
behaves just like <code>SEE_interpreter_init()</code>
(see <a href="#interp">&sect;2</a>).
</p>

<pre>void <dfn id="SEE_interpreter_init_compat">SEE_interpreter_init_compat</dfn>(struct SEE_interpreter *interp,
                int flags);</pre>

<p>The <code>flags</code> parameter is a bitwise OR of the constants
described in the following table.
</p>

<p class="note">
&#9888; Note:
The following compatibility flag names may change in the future.
</p>

<table>
<tr>
<th>Flag</th>
<th>Behaviour</th>
</tr>

<tr><td><code>SEE_COMPAT_STRICT</code>
<td>This is not really a flag. It is defined as zero, and can be used
when no compatibility flags are wanted. SEE will operate in its default
ECMA compliance mode.

<tr><td><code>SEE_COMPAT_UTF_UNSAFE</code>
<td>Treats overlong UTF-8 encodings as valid unicode characters.
You should never need this.

<tr><td><code>SEE_COMPAT_262_3B</code>
<td>
Enables optional features from Appendix B of ECMA-262 ed3, namely:
<ul>
<li>defines <code class="js">Date.prototype.toGMTString()</code>, equivalent to <code class="js">toUTCString()</code>
<li>defines <code class="js">Date.prototype.getYear()</code> and <code class="js">Date.setYear()</code>
<li>defines <code class="js">escape()</code> and <code class="js">unescape()</code> in the global object
<li>defines <code class="js">String.prototype.substr()</code>
</ul>

<tr><td><code>SEE_COMPAT_SGMLCOM</code>
<td>
        This flag makes the lexical analyser stage 
        treat the 4-character sequence
        '<code class="js">&lt;!--</code>' as if it were the
        '<code class="js">//</code>' comment introducer. 
        This is useful when parsing HTML SCRIPT elements.

<tr><td><code>SEE_COMPAT_JS11</code>
<td>
        Enables JavaScript 1.1 compatibility:
<ul>
<li>    The string representation of a bad date 
        (e.g. <code class="js">String(new Date(NaN))</code>) 
        is returned as the string
        <code class="js">"Invalid Date"</code>,
        instead of <code class="js">"NaN"</code>.

<li>    Calling <code class="js">Date</code> as a constructor or function
        will recognise Netscape-style date strings of which one
        form is '<code class="js">1/1/1999 12:30 AM</code>'.
<li>
        Conversions from a date to a string will include the timezone.

<li>    Native objects synthesize a property called
        <code class="js">__proto__</code> with the same
        value as the internal [[Prototype]] property 
        (or <code class="js">null</code>). Assignments
        to <code class="js">__proto__</code> are accepted if 
        they don't cause a cycle. 
	[EXT:7 + EXT:8]

<li>    Invalid <code class="js">\u</code> or <code class="js">\x</code>
        escapes will treat the leading
        <code class="js">\u</code> or <code class="js">\x</code> as
        a single-letter escape.
        This would be a lexical analyser error under ECMA.

<li>    Regular expression instances have a [[Call]] property, which
        is essentially equivalent to <code class="js">RegExp.prototype.exec()</code>.
        This has the side-effect of changing what the <code class="js">typeof</code>
        operator returns when applied to regular expression instances.

<li>    The <code class="js">String.prototype</code> object 
        is given the following methods that simply return the string, and
        ignore their arguments:
        <code class="js">anchor</code>,
        <code class="js">big</code>,
        <code class="js">blink</code>,
        <code class="js">bold</code>,
        <code class="js">fixed</code>,
        <code class="js">fontcolor</code>,
        <code class="js">fontsize</code>,
        <code class="js">italics</code>,
        <code class="js">link</code>,
        <code class="js">small</code>,
        <code class="js">strike</code>,
        <code class="js">sub</code> and
        <code class="js">sup</code>.
        The <code class="js">substr</code> method is also added.

</ul>


<tr><td><code>SEE_COMPAT_JS12</code>
<td>
        Enables JavaScript 1.2 compatibility:
<ul>
<li>    Includes all JavaScript 1.1 compatibility behaviour.
<li>
        The constructor <code class="js">new Array()</code> when given
        a single numeric argument will return an array consisting of
        just that argument. e.g. <code class="js">new Array(3)</code>
        is the same as <code class="js">[3]</code>. 
        This differs from the ECMA standard where an array of length 3
        would be created, viz
        <code class="js">[undefined,undefined,undefined]</code>.
        (JavaScript 1.2 <strong>only</strong>.)

<li>
        <code class="js">Boolean</code> instance objects are converted
        to their logical value in expressions that are converted to boolean.
        This differs from the ECMA standard where all object instances
        are to be converted to <code class="js">true</code>.
        For example, the condition in the statement 
        <code class="js">if (new Boolean(false))<code> statement, will
        be evaluated as <code class="js">true</code> in ECMA, and 
        <code class="js">false</code> by JavaScript 1.2.
        (JavaScript 1.2 <strong>only</strong>.)

<li>
        <code class="js">Array.prototype.toString()</code> and 
        <code class="js">Object.prototype.toString()</code> return
        string forms in literal notation, 
        e.g. <code class="js">"[1,2,3]"</code>, and
        <code class="js">"{a:1, b:2}"</code>.
        (JavaScript 1.2 <strong>only</strong>.)

<li>    <code class="js">String.prototype.split()</code> when
        operating on the empty string <code class="js">""</code>
        will return 
        an empty array <code class="js">[]</code>
        instead of
        an array consisting of the empty string, <code class="js">[""]</code>.
        (JavaScript 1.2 <strong>only</strong>.)

<li>    <code class="js">String.prototype.split()</code>, when
        given a delimiter of exactly one space character
        (<code class="js">" "</code>), will
        strip the leading whitespace from the string, and then split on
        <code class="js">/\s+/</code>.
        (JavaScript 1.2 <strong>only</strong>.)


</ul>

<tr><td><code>SEE_COMPAT_JS13</code>
<td>
        Enables JavaScript 1.3 compatibility:
<ul>
<li>    Includes JavaScript 1.1&emdash;1.2 compatibility behaviour.
</ul>

<tr><td><code>SEE_COMPAT_JS14</code>
<td>
        Enables JavaScript 1.4 compatibility:
<li>    Includes JavaScript 1.1&emdash;1.3 compatibility behaviour.
<ul>
</ul>

<tr><td><code>SEE_COMPAT_JS15</code>
<td>
        Enables JavaScript 1.5 compatibility:
<ul>
<li>    Includes JavaScript 1.1&emdash;1.4 compatibility behaviour.
<li>
        Permit conditional function declarations of the form
        <code class="js">if (1) function foo (args) { body; }</code>.
        The statement becomes syntactically identical to
        <code class="js">if (1) foo = function foo (args) { body; }</code>.
</ul>

<tr><td><code>SEE_COMPAT_EXT1</code>
<td>
Random, unsorted extensions, mainly relating to behaviour of older JavaScript:
<ul>

<li>    Enumerating over properties is done in a sorted fashion. 
        During sort, property names are ordered arithmetically if they
        are suitable as array indicies, otherwise they are ordered
        lexicographically. 
	[EXT:1]

<li>    SEE's lexical analyser will recognise octal integers (i.e.
        integers starting with '0') and will fall back to decimal if
        the token contains
        a non-octal digit.
	Same with parseInt().
	[EXT:4 + EXT:18]

<li>    Coercing native values that do not have a 
        [[DefaultValue]] internal
        property will return an object-unique string, instead of throwing
        a <code class="js">TypeError</code>.
	[EXT:5 + EXT:6]


<li>    <code class="js">Function.prototype</code> will not have a
        <code class="js">prototype</code> property of its own.
	[EXT:9]

<li>    <code class="js">Function.prototype.toString()</code>
        applied to built-in functions and
        constructors (which are not function instances) will return a bogus
        do-nothing FunctionDeclaration instead of throwing a
        <code class="js">TypeError</code>.
	[EXT:13]

<li>    The global object has its property [[Prototype]] property set to
        <code class="js">Object.prototype</code>,
        effectively making all its properties available to the global scope,
        but having the good side effect of allowing 
        <code class="js">toString()</code> to
        work anywhere.
	[EXT:17]

<li>    Calling <code class="js">eval()</code> with a 
        <code class="js">this</code> different to the global object executes
        its contents with the scope and variable object always set to
        <code class="js">this</code>
        (instead of inheriting the caller's context as per
        s10.2.2 of the standard).
	[EXT:23]

<li>    Native functions assign themselves an
        <code class="js">arguments</code>
        property when called, so that the old idiom of using
        <code class="js">f.arguments</code> inside the function 
        <code class="js">f</code> will work.
	[EXT:2 + EXT:11 + EXT:12]

<li>    The system-generated <code class="js">arguments</code> object
        created inside a function has a default-value (a comma-separated
        string representing the arguments), instead of raising a
        <code class="js">TypeError</code>. The upshot of this is that
        <code class="js">arguments</code> can be coerced into a string.
	[EXT:14]

<li>
        Reserved words can be used as identifiers (with a warning message)
	[EXT:3]
<li>
        Invalid quantifiers in regular expressions
        (e.g. <code>/a{12x}/</code>) are treated as literals instead
        of raising a SyntaxError.
	[EXT:24]
<li>
        <code class="js">RegExp</code> supports the [[HasInstance]] operator,
        meaning that <code class="js">/x*/ instanceof RegExp</code>
        will work.
	[EXT:20]
<li>
        Change the token grammar to recognise simple character classes 
        in literal regular expressions.
        This means the expression <code class="js">/[/]/</code> will
        be parsed as if it were <code class="js">/[\/]/</code>.
	[EXT:15]

<li>	In regex character classes,
	three digit octal escape sequences beginning with 
        <code class="js">\0</code> are understood.
	[EXT:25]

<li>
        Regex execution leaves results in the 
        <code class="js">RegExp</code> object, in the properteis
        <code class="js">$1</code> ...
        <code class="js">$9</code>,
        <code class="js">$_</code>,
        <code class="js">$*</code>,
        <code class="js">$+</code>,
        <code class="js">$`</code>,
        <code class="js">$'</code>,
        <code class="js">global</code>,
        <code class="js">ignoreCase</code>,
        <code class="js">input</code>,
        <code class="js">lastIndex</code>,
        <code class="js">lastMatch</code>,
        <code class="js">lastParen</code>,
        <code class="js">leftContext</code>,
        <code class="js">multiline</code>,
        <code class="js">rightContext</code>, and
        <code class="js">source</code>.
	[EXT:21]

<li>
	The global function escape() returns uppercase hex digits,
	instead of lowercase. 
	[EXT:19]
</ul>

<tr><td><code>SEE_COMPAT_ARRAYJOIN1</code>
<td>
        <code class="js">Array.join(undefined)</code> uses
        the string '<code class="js">undefined</code>'
        as the join string instead of '<code class="js">,</code>'.
        However when called without arguments will still use
        '<code class="js">,</code>'.
        Also, <code class="js">String.split(undefined)</code> will
        work in a corresponding reverse way.
	[EXT:16]

</table>

<p>
SEE now always optimises empty function calls
by skipping the expensive 
process of extending the scope chain, creating an
<code class="js">arguments</code> property, etc. and just
synthesizing <code class="js">undefined</code> for the call, instead.
This was an optional optimisation prior to SEE 2.0, but is now always
in effect.

<h3 id="compatsee">8.2 Compatibility with previous versions of SEE</h3>

<p>
As distributed, SEE has two different version numbers:
<ol>
<li>the package, release and shared library version number (e.g. 2.0)
<li>the API version number (e.g. 1.0)
</ol>

<p>
The library version is available to programs to query through the
<code>SEE_version()</code> function. 
This function returns a pointer to a static C string containing 
identifiers separated by a space character (<code>0x20</code>).
The first identifier is the name of the library (e.g. <code>"see"</code>)
and the second identifier is the package version number
(e.g. <code>2.0</code>).
Further identifiers indicate the features used when compiling the library.
This string is useful for end users to determine what capabilities
their library implementation has.

<pre>const char *<dfn id="SEE_version">SEE_version</dfn>(void);</pre>

<p>
The major and minor API version numbers indicate backward-compatible
and backward-incompatible changes to the API, i.e the interface
described in this documentation and the header files.
The API version number is independent of the package and library
version number.

<p>
Practically, developers should use the following code to signal the
rare case of major API changes when compiling:
<pre>#if SEE_VERSION_API_MAJOR &gt; 1
 #warning "SEE API major version mismatch"
#endif</pre>

<p>
This warning will indicate that past use of older API is incompatible
with newer APIs.

<p>
The API versioning rules are:
<ul>
<li>If a function, type, extern or macro has been changed since last
release so that previous use is incompatible with future use, then
the major version number is incremented and the minor version number
is reset to zero.
<li>If a function, type, extern or macro has been added since last
release such that its future use is incompatible with previous headers
with the same API major version number, then the minor version number
is incremented.
</ul>

<p>
This document will indicate at what API version new API elements are added,
defaulting to 1.0.

<pre>const int <dfn id="SEE_VERSION_API_MAJOR">SEE_VERSION_API_MAJOR</dfn>;
const int <dfn id="SEE_VERSION_API_MINOR">SEE_VERSION_API_MINOR</dfn>;</pre>


<h2 id="security">9 Security</h2>
<p>
The SEE library provides a simple interface for the host application 
to manage security contexts for scripts and host functions.

<p>
The host application should manage the 'current' security domain
by setting the interpreter's <code>sec_domain</code> field.

<p>
During execution, when callable objects are created, they inherit the 
value of the interpreter's <code>sec_domain</code> field.
Just before an object is called (either through the
<code>SEE_OBJECT_CALL()</code> or
<code>SEE_OBJECT_CONSTRUCT()</code> macro),
the interpreter's <code>sec_domain</code> field is temporarily modified
by SEE in the following steps:
<ol>
<li>If <code>SEE_system.transit_sec_domain</code> is <code>NULL</code>,
	then no modification occurs, and execution continues; otherwise
<li>If the object's class does not provide a <code>get_sec_domain()</code>
	method, then no modification occurs, and execution continues; otherwise
<li>The object's <code>get_sec_domain()</code> method is called to
	obtain its security domain. If its security domain is pointer
	identical to the current security domain, then no modification occurs,
	and execution continues; otherwise
<li>The <code>SEE_system.transit_sec_domain()</code> function is called to
	change the security domain of the interpreter, and execution continues.
</ol>

<p>	
When an exception occurs during the call, or the object's call completes
successfully, the interpreter's security domain is restored to its 
value before the call.

<p>
The initial value of the interpreter's <code>sec_domain</code>
field is NULL. 
Consequently, all built-in SEE function objects will have a security 
domain of <code>NULL</code>.
The following functions (amongst others) are sensitive to the interpreter's
<code>sec_domain</code> field and will record it in any callable objects 
they produce:
<ul>
<li><code>SEE_Global_eval()</code>,
<li><code>SEE_Function_new()</code>,
<li><code>SEE_cfunction_make()</code>,
</ul>

<p>
Apart from the
<code>SEE_OBJECT_CALL()</code> and
<code>SEE_OBJECT_CONSTRUCT()</code> macros,
which only save and restore the <code>sec_domain</code>,
no other function in the SEE library will changes the 
interpreter's <code>sec_domain</code> value.

<h3 id="secguide">9.1 Guidelines for using the security framework</h3>
<p>
If you plan to make use of SEE's security framework, here are some guidelines:
<ol>
<li>
Design a domain structure that represents a subset of entities to which 
you will grant or deny access. These entities are called <i>principals</i>.
The domain structure then represents the intersection of the rights of
multiple principals. 
<li>
Design an authorization model for your code based on <i>resources</i>
and <i>operations</i>. 
Implement an assertion-like function that 
throws an exception unless
the current domain is allowed to perform the given operation on
the given resource. 
This function should be called by your sensitive functions.
<li>Design a domain transition function for SEE that, given two security
domains (the caller and the callee), chooses one or generates a new 
representative domain, and assigns it into the interpreter.
Set this function as
the <code>SEE_system.transit_sec_domain()</code> function.
Note that SEE's built-in functions will have a <code>NULL</code> domain.
<li>When you get source text from a trusted or untrusted source, 
then before calling 
<code>SEE_Global_eval()</code>,
<code>SEE_Function_new()</code>, or even
<code>SEE_cfunction_make()</code>,
first set the interpreter's <code>sec_domain</code> field
to reflect the principal that controls the source.
Be mindful to restore the security domain when you have finished,
especially during exceptions.
</ol>

<h2 id="debug">10 Debugging facilities</h2>

<p>
The SEE library contains various debugging facilities, that are
omitted if it is compiled with the <code>NDEBUG</code> preprocessor define.
</p>

<p>
These functions are intended for the developer to use while application 
debugging, and not for general use.
</p>

<pre>void <dfn id="SEE_PrintValue">SEE_PrintValue</dfn>(struct SEE_interpreter *interp, 
                struct SEE_value *val, FILE *file);
void <dfn id="SEE_PrintObject">SEE_PrintObject</dfn>(struct SEE_interpreter *interp, 
                struct SEE_object *obj, FILE *file);
void <dfn id="SEE_PrintString">SEE_PrintString</dfn>(struct SEE_interpreter *interp, 
                struct SEE_string *str, FILE *file);
void <dfn id="SEE_PrintTraceback">SEE_PrintTraceback</dfn>(struct SEE_interpreter *interp, 
                FILE *file);</pre>

<p>
If debugging the library itself, it is worth reading the source code to
find the debug flag variables that can be turned on by the host 
application to enable verbose traces during execution.
</p>

<p>
Defining the
<code>NDEBUG</code> preprocessor symbol when building the library
also disables (slow) internal assertions that would otherwise
help show up application misuse of the API.
</p>

<p>
The interpreter structure provides a <code>trace</code>
callback field, which is called on every transition through the executable
AST. This callback is passed a handle to the current execution context,
(a <code>struct SEE_context *</code>)
and an external debugger may examine it directly, or with the
<code>SEE_context_eval()</code> utility function, which is otherwise 
functionally identical to <code>SEE_Global_eval()</code>. 
<code>SEE_context_eval()</code>
is intended only for use by external debuggers attached to the 
<code>trace</code> callback.
The <code>trace</code> callback should be disabled
(by setting it to <code>NULL</code>)
when calling <code>SEE_Global_eval()</code>, otherwise re-entrant tracing
will occur.
</p>

<pre>void <dfn id="SEE_context_eval">SEE_context_eval</dfn>(struct SEE_context *context,
                struct SEE_string *expr, struct SEE_value *res);</pre>


<h2 id="ref">References</h2>

<ul>
<li id="ref-ecma"><a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">ECMA-262, ECMAScript language specification</a>, 3rd edition, December 1999.
<li id="ref-boehm"><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">The Boehm-Weiser garbage collection package for C and C++</a>, accessed March 2004
<!-- <li id="ref-gc"><a href="http://www.iecc.com/gclist/GC-faq.html">GC-LIST FAQ</a>, accessed April 2004 -->
<li id="ref-utf16">Hoffman et al., <a href="http://www.ietf.org/rfc/rfc2781.txt">UTF-16, an encoding of ISO 10646</a> [RFC 2781], February 2000
<li id="ref-issues">Boehm, <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/issues.html">Advantages and Disadvantages of Conservative Garbage Collection</a>, accessed March 2004
<li id="ref-unicode">Unicode Inc., <a href="http://www.unicode.org/versions/enumeratedversions.html#Unicode_2_1_9">Unicode 2.1.9</a>, April 1999
<li id="netscape-js13">Netscape Communications Corp., <a href="http://devedge-temp.mozilla.org/library/manuals/2000/javascript/1.3/reference/">Client-Side JavaScript Reference 1.3</a>, 1997
<li id="netscape-js14">Netscape Communications Corp., <a href="http://devedge-temp.mozilla.org/library/manuals/2000/javascript/1.4/reference/">Client-Side JavaScript Reference 1.4</a>, 1998
<li id="netscape-js15">Netscape Communications Corp., <a href="http://devedge-temp.mozilla.org/library/manuals/2000/javascript/1.5/reference/">Client-Side JavaScript Reference 1.5</a>, 2000
</ul>

<h2 id="idx">Name index</h2>

<table class="index">
<tr>
<td>
<a href="#SEE_ABORT">SEE_ABORT</a><br>
<a href="#SEE_ALLOCA">SEE_ALLOCA</a><br>
<a href="#SEE_CAUGHT">SEE_CAUGHT</a><br>
<a href="#SEE_cfunction_make">SEE_cfunction_make</a><br>
<a href="#SEE_context_eval">SEE_context_eval</a><br>
<a href="#SEE_DEFAULT_CATCH">SEE_DEFAULT_CATCH</a><br>
<a href="#SEE_ENUM_NEXT">SEE_ENUM_NEXT</a><br>
<a href="#SEE_Error_make">SEE_Error_make</a><br>
<a href="#SEE_error_throw">SEE_error_throw</a><br>
<a href="#SEE_error_throw_string">SEE_error_throw_string</a><br>
<a href="#SEE_error_throw_sys">SEE_error_throw_sys</a><br>
<a href="#SEE_Function_new">SEE_Function_new</a><br>
<a href="#SEE_gcollect">SEE_gcollect</a><br>
<a href="#SEE_Global_eval">SEE_Global_eval</a><br>
<a href="#SEE_Infinity">SEE_Infinity</a><br>
<a href="#struct_SEE_input">SEE_input</a> struct<br>
<a href="#struct_SEE_inputclass">SEE_inputclass</a> struct<br>
<a href="#SEE_INPUT_CLOSE">SEE_INPUT_CLOSE</a><br>
<a href="#SEE_input_file">SEE_input_file</a><br>
<a href="#SEE_INPUT_NEXT">SEE_INPUT_NEXT</a><br>
<a href="#SEE_input_string">SEE_input_string</a><br>
<a href="#SEE_input_utf8">SEE_input_utf8</a><br>
<a href="#SEE_intern">SEE_intern</a><br>
<a href="#SEE_intern_ascii">SEE_intern_ascii</a><br>
<a href="#SEE_intern_global">SEE_intern_global</a><br>
<td>
<a href="#SEE_interpreter_init">SEE_interpreter_init</a><br>
<a href="#SEE_interpreter_init_compat">SEE_interpreter_init_compat</a><br>
<a href="#SEE_mem_exhausted_hook">SEE_mem_exhausted_hook</a><br>
<a href="#SEE_mem_free_hook">SEE_mem_free_hook</a><br>
<a href="#SEE_mem_malloc_hook">SEE_mem_malloc_hook</a><br>
<a href="#SEE_mem_malloc_string_hook">SEE_mem_malloc_string_hook</a><br>
<a href="#struct_SEE_module">SEE_module</a> struct<br>
<a href="#SEE_module_add">SEE_module_add</a><br>
<a href="#SEE_MODULE_MAGIC">SEE_MODULE_MAGIC</a><br>
<a href="#SEE_MODULE_PRIVATE">SEE_MODULE_PRIVATE</a><br>
<a href="#SEE_NaN">SEE_NaN</a><br>
<a href="#struct_SEE_native">SEE_native</a> struct<br>
<a href="#SEE_native_init">SEE_native_init</a><br>
<a href="#SEE_NEW">SEE_NEW</a><br>
<a href="#SEE_NEW_ARRAY">SEE_NEW_ARRAY</a><br>
<a href="#SEE_NEW_FINALIZE">SEE_NEW_FINALIZE</a><br>
<a href="#SEE_NEW_STRING_ARRAY">SEE_NEW_STRING_ARRAY</a><br>
<a href="#SEE_NUMBER_ISFINITE">SEE_NUMBER_ISFINITE</a><br>
<a href="#SEE_NUMBER_ISINF">SEE_NUMBER_ISINF</a><br>
<a href="#SEE_NUMBER_ISNAN">SEE_NUMBER_ISNAN</a><br>
<a href="#SEE_NUMBER_ISNINF">SEE_NUMBER_ISNINF</a><br>
<a href="#SEE_NUMBER_ISPINF">SEE_NUMBER_ISPINF</a><br>
<a href="#struct_SEE_object">SEE_object</a> struct<br>
<a href="#struct_SEE_objectclass">SEE_objectclass</a> struct<br>
<a href="#SEE_OBJECT_CALL">SEE_OBJECT_CALL</a><br>
<td>
<a href="#SEE_OBJECT_CANPUT">SEE_OBJECT_CANPUT</a><br>
<a href="#SEE_OBJECT_CONSTRUCT">SEE_OBJECT_CONSTRUCT</a><br>
<a href="#SEE_OBJECT_DEFAULTVALUE">SEE_OBJECT_DEFAULTVALUE</a><br>
<a href="#SEE_OBJECT_DELETE">SEE_OBJECT_DELETE</a><br>
<a href="#SEE_OBJECT_ENUMERATOR">SEE_OBJECT_ENUMERATOR</a><br>
<a href="#SEE_OBJECT_GET">SEE_OBJECT_GET</a><br>
<a href="#SEE_OBJECT_GET_SEC_DOMAIN">SEE_OBJECT_GET_SEC_DOMAIN</a><br>
<a href="#SEE_OBJECT_HASINSTANCE">SEE_OBJECT_HASINSTANCE</a><br>
<a href="#SEE_OBJECT_HASPROPERTY">SEE_OBJECT_HASPROPERTY</a><br>
<a href="#SEE_OBJECT_HAS_CALL">SEE_OBJECT_HAS_CALL</a><br>
<a href="#SEE_OBJECT_HAS_CONSTRUCT">SEE_OBJECT_HAS_CONSTRUCT</a><br>
<a href="#SEE_OBJECT_HAS_ENUMERATOR">SEE_OBJECT_HAS_ENUMERATOR</a><br>
<a href="#SEE_OBJECT_HAS_GET_SEC_DOMAIN">SEE_OBJECT_HAS_GET_SEC_DOMAIN</a><br>
<a href="#SEE_OBJECT_HAS_HASINSTANCE">SEE_OBJECT_HAS_HASINSTANCE</a><br>
<a href="#SEE_Object_new">SEE_Object_new</a><br>
<a href="#SEE_OBJECT_PUT">SEE_OBJECT_PUT</a><br>
<a href="#SEE_parse_args">SEE_parse_args</a><br>
<a href="#SEE_PrintObject">SEE_PrintObject</a><br>
<a href="#SEE_PrintString">SEE_PrintString</a><br>
<a href="#SEE_PrintTraceback">SEE_PrintTraceback</a><br>
<a href="#SEE_PrintValue">SEE_PrintValue</a><br>
<a href="#SEE_SET_BOOLEAN">SEE_SET_BOOLEAN</a><br>
<a href="#SEE_SET_NULL">SEE_SET_NULL</a><br>
<a href="#SEE_SET_NUMBER">SEE_SET_NUMBER</a><br>
<a href="#SEE_SET_OBJECT">SEE_SET_OBJECT</a><br>
<a href="#SEE_SET_STRING">SEE_SET_STRING</a><br>
<td>
<a href="#SEE_SET_UNDEFINED">SEE_SET_UNDEFINED</a><br>
<a href="#struct_SEE_string">SEE_string</a> struct<br>
<a href="#SEE_string_addch">SEE_string_addch</a><br>
<a href="#SEE_STRING_ALLOCA">SEE_STRING_ALLOCA</a><br>
<a href="#SEE_string_append">SEE_string_append</a><br>
<a href="#SEE_string_append_ascii">SEE_string_append_ascii</a><br>
<a href="#SEE_string_append_int">SEE_string_append_int</a><br>
<a href="#SEE_string_cmp">SEE_string_cmp</a><br>
<a href="#SEE_string_concat">SEE_string_concat</a><br>
<a href="#SEE_string_dup">SEE_string_dup</a><br>
<a href="#SEE_string_fputs">SEE_string_fputs</a><br>
<a href="#SEE_string_literal">SEE_string_literal</a><br>
<a href="#SEE_string_new">SEE_string_new</a><br>
<a href="#SEE_string_sprintf">SEE_string_sprintf</a><br>
<a href="#SEE_string_substr">SEE_string_substr</a><br>
<a href="#SEE_string_toutf8">SEE_string_toutf8</a><br>
<a href="#SEE_string_vsprintf">SEE_string_vsprintf</a><br>
<a href="#SEE_THROW">SEE_THROW</a><br>
<a href="#SEE_ToBoolean">SEE_ToBoolean</a><br>
<a href="#SEE_ToInt32">SEE_ToInt32</a><br>
<a href="#SEE_ToInteger">SEE_ToInteger</a><br>
<a href="#SEE_ToNumber">SEE_ToNumber</a><br>
<a href="#SEE_ToObject">SEE_ToObject</a><br>
<a href="#SEE_ToPrimitive">SEE_ToPrimitive</a><br>
<a href="#SEE_ToString">SEE_ToString</a><br>
<td>
<a href="#SEE_ToUint16">SEE_ToUint16</a><br>
<a href="#SEE_ToUint32">SEE_ToUint32</a><br>
<a href="#SEE_TRY">SEE_TRY</a><br>
<a href="#struct_SEE_value">SEE_value</a> struct<br>
<a href="#SEE_VALUE_COPY">SEE_VALUE_COPY</a><br>
<a href="#SEE_VALUE_GET_TYPE">SEE_VALUE_GET_TYPE</a><br>
<a href="#SEE_version">SEE_version</a><br>
<a href="#SEE_VERSION_API_MAJOR">SEE_VERSION_API_MAJOR</a><br>
<a href="#SEE_VERSION_API_MINOR">SEE_VERSION_API_MINOR</a><br>
</table>

<hr>
<p class="misc">
&copy; David Leonard, 2004.
This documentation may be entirely reproduced and freely distributed,
as long as this copyright notice remains intact, and either the 
distributed reproduction or translation is a complete and bona fide copy, or
the modified reproduction is subtantially the same and includes a brief
summary of the modifications made. 
</p>

<pre>$Id$</pre>

<ul class="misc">
<li>Jan 2004: clean up and more examples
<li>Mar 2004: add compatibility section, prototypes, index
<li>Aug 2004: remove references to deprecated <code>SEE_ENUM_RESET</code>
<li>Jan 2005: add <code>SEE_native_init</code>
</ul>

</body>
</html>
